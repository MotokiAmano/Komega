使用方法
========

各ライブラリともユーザーはライブラリ名および型を指定し,

-  初期設定 (init関数)

-  アップデート (update関数)

-  計算情報出力 (getcoef, getvec関数などを呼び出力)

-  終了関数 (finalize関数)

の手順で関数を使用することで, 計算が実施される. なお,
リスタートを行う場合には

-  初期設定関数(restart関数)

-  アップデート (update関数)

-  計算情報出力 (getcoef, getvec関数などを呼び出力)

-  終了関数 (finalize関数)

の手順で実行する. fortran から呼び出すときには

.. code-block:: fortran

      USE komega_????

のようにモジュールを呼び出す. ``"????"`` の部分には, ``"CG_R"``,
``"CG_C"``, ``"COCG"``, ``"BiCG"`` が入る.
MPI/Hybrid並列版のルーチンを利用するときには,

.. code-block:: fortran

      USE pkomega_????

のようにする.

C/C++で書かれたプログラムから呼び出すときには、

.. code-block:: c

    #include komega_????.h

のようにヘッダーファイルを読み込む。
また、スカラー引数はすべてポインタとして渡す。
MPI/Hybrid並列版のルーチンを利用するときには,

.. code-block:: c

    #include pkomega_????.h

のようにする。
またライブラリに渡すコミュニケーター変数を、次のようにC/C++のものからfortranのものに変換する。

.. code-block:: c

      comm_f = MPI_Comm_c2f(comm_c);

各ルーチンの説明
----------------

``komega_????_init``, ``pkomega_????_init``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ライブラリ内部変数の割り付けおよび初期化を行う.
シフト線形方程式を解く前に, 一番初めに実行する.

構文

Fortran シリアル/OpenMP版

.. code-block:: fortran

    CALL komega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold)
    CALL komega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold)
    CALL komega_COCG_init(ndim, nl, nz, x, z, itermax, threshold)
    CALL komega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold)

Fortran MPI/Hybrid並列版

.. code-block:: fortran

    CALL pkomega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold, comm)
    CALL pkomega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold, comm)
    CALL pkomega_COCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)
    CALL pkomega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)

C/C++ シリアル/OpenMP版

.. code-block:: c

    komega_CG_R_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
    komega_CG_C_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
    komega_COCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
    komega_BiCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);

C/C++ MPI/Hybrid並列版

.. code-block:: c

    pkomega_CG_R_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
    pkomega_CG_C_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
    pkomega_COCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
    pkomega_BiCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);

パラメーター

-  ``ndim``

   ``INTEGER``. スカラー. 入力. 線形方程式の次元.

-  ``nl``

   ``INTEGER``. スカラー. 入力. 射影された解ベクトルの次元.

-  ``nz``

   ``INTEGER``. スカラー. 入力. シフト点の数.

-  ``x``

   ``DOUBLE PRECISION`` (``CG_R_init`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``nl*nz`` の配列. 出力. 解ベクトル.
   ``0`` ベクトルが返される.

-  ``z``

   ``DOUBLE PRECISION`` (``CG_R_init``, ``CG_C_init`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). 長さ ``nz`` の配列. 入力. シフト点.

-  ``itermax``

   ``INTEGER``. スカラー. 入力.
   リスタート用配列の割り付けのための最大反復回数.
   これを ``0`` にした場合にはリスタート用配列を割りつけない(したがって後述のリスタート用変数の出力を行えない)

-  ``threshold``

   ``DOUBLE PRECISION``. スカラー. 入力. 収束判定用しきい値.
   シード方程式の残差ベクトルの2-ノルムがこの値を下回った時に収束したと判定する.

-  ``comm``

   ``INTEGER``. スカラー. 入力. MPI/Hybrid並列版のみ.
   MPIのコミニュケーター( ``MPI_COMM_WORLD`` など)を入れる.

``komega_????_restart``, ``pkomega_????_restart``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

リスタートを行う場合に ``?_init`` の代わりに用いる.
ライブラリ内部変数の割り付けおよび初期化を行う.
シフト線形方程式を解く前に, 一番初めに実行する.

構文

Fortran (シリアル/OpenMP版)

.. code-block:: fortran

    CALL komega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
    &                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
    &                 z_seed, r_l_save)

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
    &                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
    &                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
    &                 z_seed, r_l_save)

C/C++ (シリアル/OpenMP版)

.. code-block:: c

    komega_CG_R_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
     komega_CG_C_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
    komega_COCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
    komega_BiCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
    &                 &iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
    &                 &z_seed, r_l_save);

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_CG_C_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_COCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
    &                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_BiCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
    &                 &iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
    &                 &z_seed, r_l_save);

パラメーター

-  ``ndim, nl, nz, x, z, itermax, threshold, comm``

   ``?_init`` と同様.

-  ``status``

   ``INTEGER``. 長さ ``3`` の配列. 出力. エラーコードを返す.

   第一成分( ``status(1)``)
       解が収束した場合,
       もしくは計算が破綻した場合には現在の総反復回数に
       マイナスが付いた値が返される.
       それ以外の場合には現在の総反復回数(マイナスが付かない)が返される.
       ``status(1)`` が正の値の時のみ反復を続行できる.
       それ以外の場合は反復を進めても有意な結果は得られない.

   第二成分( ``status(2)``)
       ``itermax`` を有限にして, かつ ``itermax`` 回の反復で
       収束に達しなかった場合には ``1`` が返される.
       :math:`\alpha` が発散した場合には ``2`` が返される.
       :math:`\pi_{\rm seed}` が0にになった場合には ``3`` が返される.
       ``COCG_restart`` もしくは ``BiCG_restart`` で,
       残差ベクトルと影の残差ベクトルが直交した場合には ``4`` が返される.
       それ以外の場合には ``0`` が返される.

   第三成分( ``status(3)``)
       シード点のindexが返される.

-  ``iter_old``

   ``INTEGER``. スカラー. 入力. 先行する計算での反復回数.

-  ``v2``

   ``DOUBLE PRECISION`` (``CG_R_restart`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``ndim`` の配列. 入力.
   先行する計算での最後の残差ベクトル.

-  ``v12``

   ``DOUBLE PRECISION`` (``CG_R_restart`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``ndim`` の配列. 入力.
   先行する計算での最後から2番目の残差ベクトル.

-  ``alpha_save``

   ``DOUBLE PRECISION`` (``CG_R_restart``, ``CG_C_restart`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). 長さ ``iter_old`` の配列. 入力.
   先行する計算での各反復での(Bi)CG法のパラメーター :math:`\alpha`.

-  ``beta_save``

   ``DOUBLE PRECISION`` (``CG_R_restart``, ``CG_C_restart`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). 長さ ``iter_old`` の配列. 入力.
   先行する計算での各反復での(Bi)CG法のパラメーター :math:`\beta`.

-  ``z_seed``

   ``DOUBLE PRECISION`` (``CG_R_restart``, ``CG_C_restart`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). スカラー. 入力.
   先行する計算でのシードシフト.

-  ``r_l_save``

   ``DOUBLE PRECISION`` (``CG_R_restart`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``nl*iter_old`` の配列. 入力.
   先行する計算での各反復での射影された残差ベクトル.

-  ``v4``

   ``BiCG_restart`` の場合のみ使用. ``DOUBLE COMPLEX``.
   長さ ``ndim`` の配列. 入力. 先行する計算での最後の影の残差ベクトル.

-  ``v14``

   ``BiCG_restart`` の場合のみ使用. ``DOUBLE COMPLEX``.
   長さ ``ndim`` の配列. 入力.
   先行する計算での最後から2番目の影の残差ベクトル.

``komega_????_update``, ``pkomega_????_update``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ループ内で行列ベクトル積と交互に呼ばれて解を更新する.

構文

Fortran (シリアル/OpenMPI版)

.. code-block:: fortran

    CALL komega_CG_R_update(v12, v2, x, r_l, status)
    CALL komega_CG_C_update(v12, v2, x, r_l, status)
    CALL komega_COCG_update(v12, v2, x, r_l, status)
    CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_update(v12, v2, x, r_l, status)
    CALL pkomega_CG_C_update(v12, v2, x, r_l, status)
    CALL pkomega_COCG_update(v12, v2, x, r_l, status)
    CALL pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status)

C/C++ (シリアル/OpenMPI版)

.. code-block:: c

    komega_CG_R_update(v12, v2, x, r_l, status);
    komega_CG_C_update(v12, v2, x, r_l, status);
    komega_COCG_update(v12, v2, x, r_l, status);
    komega_BiCG_update(v12, v2, v14, v4, x, r_l, status);

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_update(v12, v2, x, r_l, status);
    pkomega_CG_C_update(v12, v2, x, r_l, status);
    pkomega_COCG_update(v12, v2, x, r_l, status);
    pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status);

パラメーター

-  ``v12``

   ``DOUBLE PRECISION`` (``CG_R_update`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``ndim`` の配列. 入出力.
   入力は残差ベクトル( ``v2``)と行列の積. 出力は,
   更新された残差ベクトルの2-ノルムが,
   先頭の要素に格納される(これは収束の具合を表示して調べる時などに用いる).

-  ``v2``

   ``DOUBLE PRECISION`` (``CG_R_update`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``ndim`` の配列. 入出力. 入力は残差ベクトル.
   出力は更新された残差ベクトル.

-  ``v14``

   ``BiCG_update`` の場合のみ使用. ``DOUBLE COMPLEX``.
   長さ ``ndim`` の配列. 入力. 影の残差ベクトル( ``v4``)と行列の積.

-  ``v4``

   ``BiCG_update`` の場合のみ使用. ``DOUBLE COMPLEX``.
   長さ ``ndim`` の配列. 入出力. 入力は影の残差ベクトル.
   出力は更新された影の残差ベクトル.

-  ``status``

   ``INTEGER``. 長さ ``3`` の配列. 出力. エラーコードを返す.

   第一成分( ``status(1)``)
       解が収束した場合,
       もしくは計算が破綻した場合には現在の総反復回数に
       マイナスが付いた値が返される.
       それ以外の場合には現在の総反復回数(マイナスが付かない)が返される.
       ``status(1)`` が正の値の時のみ反復を続行できる.
       それ以外の場合は反復を進めても有意な結果は得られない.

   第二成分( ``status(2)``)
       ``?_init`` ルーチンで, ``itermax`` を有限にして,
       かつ ``itermax`` 回の反復で
       収束に達しなかった場合には ``1`` が返される.
       :math:`\alpha` が発散した場合には ``2`` が返される.
       :math:`\pi_{\rm seed}` が0にになった場合には ``3`` が返される.
       ``COCG_update`` もしくは ``BiCG_update`` で,
       残差ベクトルと影の残差ベクトルが直交した場合には ``4`` が返される.
       それ以外の場合には ``0`` が返される.

   第三成分( ``status(3)``)
       シード点のindexが返される.

``komega_????_getcoef``, ``pkomega_????_getcoef``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

後でリスタートをするときに必要な係数を取得する.
このルーチンを呼び出すためには,
``?_init`` ルーチンで ``itermax`` を ``0`` 以外の値にしておく必要がある.

構文

Fortran (シリアル/OpenMP版)

.. code-block:: fortran

    CALL komega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL komega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    CALL pkomega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)

C/C++ (シリアル/OpenMP版)

.. code-block:: c

    komega_CG_R_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    komega_CG_C_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    komega_COCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    komega_BiCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_CG_C_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_COCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
    pkomega_BiCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);

パラメーター

-  ``alpha_save``

   ``DOUBLE PRECISION`` (``CG_R_getoef``, ``CG_C_getoef`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). 総反復回数と同じ長さの配列. 出力.
   各反復での(Bi)CG法のパラメーター :math:`\alpha`.

-  ``beta_save``

   ``DOUBLE PRECISION`` (``CG_R_getoef``, ``CG_C_getoef`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). 総反復回数と同じ長さの配列. 出力.
   各反復での(Bi)CG法のパラメーター :math:`\beta`.

-  ``z_seed``

   ``DOUBLE PRECISION`` (``CG_R_getoef``, ``CG_C_getoef`` の場合),
   ``DOUBLE COMPLEX`` (それ以外). スカラー. 出力. シードシフト.

-  ``r_l_save``

   ``DOUBLE PRECISION`` (``CG_R_getoef`` の場合), ``DOUBLE COMPLEX``
   (それ以外). ``nl`` :math:`\times` 総反復回数の長さ配列. 出力.
   各反復での射影された残差ベクトル.

``komega_????_getvec``, ``pkomega_????_getvec``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

後でリスタートをするときに必要な残差ベクトルを取得する.
このルーチンを呼び出すためには,
``?_init`` ルーチンで ``itermax`` を ``0`` 以外の値にしておく必要がある.

構文

Fortran (シリアル/OpenMP版)

.. code-block:: fortran

    CALL komega_CG_R_getvec(r_old)
    CALL komega_CG_C_getvec(r_old)
    CALL komega_COCG_getvec(r_old)
    CALL komega_BiCG_getvec(r_old, r_tilde_old)

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_getvec(r_old)
    CALL pkomega_CG_C_getvec(r_old)
    CALL pkomega_COCG_getvec(r_old)
    CALL pkomega_BiCG_getvec(r_old, r_tilde_old)

C/C++ (シリアル/OpenMP版)

.. code-block:: c

    komega_CG_R_getvec(r_old);
    komega_CG_C_getvec(r_old);
    komega_COCG_getvec(r_old);
    komega_BiCG_getvec(r_old, r_tilde_old);

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_getvec(r_old);
    pkomega_CG_C_getvec(r_old);
    pkomega_COCG_getvec(r_old);
    pkomega_BiCG_getvec(r_old, r_tilde_old);

パラメーター

-  ``r_old``

   ``DOUBLE PRECISION`` (``CG_R_getvec`` の場合), ``DOUBLE COMPLEX``
   (それ以外). 長さ ``ndim`` の配列. 出力.
   先行する計算での最後から2番目の残差ベクトル.

-  ``r_tilde_old``

   ``BiCG_getvec`` の場合のみ使用. ``DOUBLE COMPLEX``.
   長さ ``ndim`` の配列. 出力.
   先行する計算での最後から2番目の影の残差ベクトル.

``komega_????_getresidual``, ``pkomega_????_getresidual``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

各シフト点での残差ベクトルの2-ノルムを取得する.
このルーチンは ``komega_????_init`` と ``komega_????_finalize`` の間の
任意の場所で呼び出すことが出来る. また,
いつ何回呼び出しても最終的な計算結果には影響を与えない.

構文

Fortran (シリアル/OpenMP版)

.. code-block:: fortran

    CALL komega_CG_R_getresidual(res)
    CALL komega_CG_C_getresidual(res)
    CALL komega_COCG_getresidual(res)
    CALL komega_BiCG_getresidual(res)

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_getresidual(res)
    CALL pkomega_CG_C_getresidual(res)
    CALL pkomega_COCG_getresidual(res)
    CALL pkomega_BiCG_getresidual(res)

C/C++ (シリアル/OpenMP版)

.. code-block:: c

    komega_CG_R_getresidual(res);
    komega_CG_C_getresidual(res);
    komega_COCG_getresidual(res);
    komega_BiCG_getresidual(res);

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_getresidual(res);
    pkomega_CG_C_getresidual(res);
    pkomega_COCG_getresidual(res);
    pkomega_BiCG_getresidual(res);

パラメーター

-  ``res``

   ``DOUBLE PRECISION``. 長さ ``nz`` の配列. 出力.
   各シフト点での残差ベクトルの2-ノルム.

``komega_????_finalize``, ``pkomega_????_finalize``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ライブラリ内部で割りつけた配列のメモリを解放する.

構文

Fortran (シリアル/OpenMP版)

.. code-block:: fortran

    CALL komega_CG_R_finalize()
    CALL komega_CG_C_finalize()
    CALL komega_COCG_finalize()
    CALL komega_BiCG_finalize()

Fortran (MPI/ハイブリッド並列版)

.. code-block:: fortran

    CALL pkomega_CG_R_finalize()
    CALL pkomega_CG_C_finalize()
    CALL pkomega_COCG_finalize()
    CALL pkomega_BiCG_finalize()

C/C++ (シリアル/OpenMP版)

.. code-block:: c

    komega_CG_R_finalize();
    komega_CG_C_finalize();
    komega_COCG_finalize();
    komega_BiCG_finalize();

C/C++ (MPI/ハイブリッド並列版)

.. code-block:: c

    pkomega_CG_R_finalize();
    pkomega_CG_C_finalize();
    pkomega_COCG_finalize();
    pkomega_BiCG_finalize();

Shifted BiCGライブラリを使用したソースコードの例
------------------------------------------------

以下, 代表的な例としてShifted BiCGライブラリの場合の使用方法を記載する.

.. code-block:: fortran

    PROGRAM my_prog
      !
      USE komega_bicg, ONLY : komega_BiCG_init, komega_BiCG_restart, &
      &                       komega_BiCG_update, komega_BiCG_getcoef, &
      &                       komega_BiCG_getvec, komega_BiCG_finalize
      USE solve_cc_routines, ONLY : input_size, input_restart, &
      &                             projection, &
      &                             hamiltonian_prod, generate_system, &
      &                             output_restart, output_result
      !
      IMPLICIT NONE
      !
      INTEGER,SAVE :: &
      & rnd_seed, &
      & ndim,    & ! Size of Hilvert space
      & nz,      & ! Number of frequencies
      & nl,      & ! Number of Left vector
      & itermax, & ! Max. number of iteraction
      & iter_old   ! Number of iteraction of previous run
      !
      REAL(8),SAVE :: &
      & threshold ! Convergence Threshold
      !
      COMPLEX(8),SAVE :: &
      & z_seed ! Seed frequency
      !
      COMPLEX(8),ALLOCATABLE,SAVE :: &
      & z(:)         ! (nz): Frequency
      !
      COMPLEX(8),ALLOCATABLE,SAVE :: &
      & ham(:,:), &
      & rhs(:), &
      & v12(:), v2(:), & ! (ndim): Working vector
      & v14(:), v4(:), & ! (ndim): Working vector
      & r_l(:), & ! (nl) : Projeccted residual vector 
      & x(:,:) ! (nl,nz) : Projected result 
      !
      ! Variables for Restart
      !
      COMPLEX(8),ALLOCATABLE,SAVE :: &
      & alpha(:), beta(:) ! (iter_old) 
      !
      COMPLEX(8),ALLOCATABLE,SAVE :: &
      & r_l_save(:,:) ! (nl,iter_old) Projected residual vectors
      !
      ! Variables for Restart
      !
      INTEGER :: &
      & itermin, & ! First iteration in this run
      & iter,    & ! Counter for Iteration
      & status(3)
      !
      ! Input Size of vectors
      !
      CALL input_size(ndim,nl,nz)
      !
      ALLOCATE(v12(ndim), v2(ndim), v14(ndim), v4(ndim), r_l(nl), &
      &        x(nl,nz), z(nz), ham(ndim,ndim), rhs(ndim))
      !
      CALL generate_system(ndim, ham, rhs, z)
      !
      ! Check: Whether the restart file is exist.
      !
      CALL input_restart(iter_old, zseed, alpha, beta, r_l_save)
      !
      WRITE(*,*)
      WRITE(*,*) "#####  CG Initialization  #####"
      WRITE(*,*)
      !
      IF(iter_old > 0) THEN
        !
        ! When restarting, counter
        !
        itermin = iter_old + 1
        CALL komega_BiCG_restart(ndim, nl, nz, x, z, max(0,itermax), &
        &                        threshold, &
        &                 status, iter_old, v2, v12, v4, v14, alpha, &
        &                 beta, z_seed, r_l_save)
        !
        ! These vectors were saved in BiCG routine
        !
        DEALLOCATE(alpha, beta, r_l_save)
        !
        IF(status(1) /= 0) GOTO 10
        !
      ELSE
         !
         itermin = 1
         !
         ! Generate Right Hand Side Vector
         !
         v2(1:ndim) = rhs(1:ndim)
         v4(1:ndim) = CONJG(v2(1:ndim))
         !v4(1:ndim) = v2(1:ndim)
         !
         CALL komega_BiCG_init(ndim, nl, nz, x, z, max(0,itermax), &
         &                     threshold)
         !
      END IF
      !
      ! BiCG Loop
      !
      WRITE(*,*)
      WRITE(*,*) "#####  CG Iteration  #####"
      WRITE(*,*)
      !
      DO iter = 1, abs(itermax)
         !
         ! Projection of Residual vector into the space
         ! spaned by left vectors
         !
         r_l(1:nl) = projection(v2(1:nl))
         !
         ! Matrix-vector product
         !
         CALL hamiltonian_prod(Ham, v2, v12)
         CALL hamiltonian_prod(Ham, v4, v14)
         !
         ! Update result x with BiCG
         !
         CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
         !
         WRITE(*,'(a,i,a,3i,a,e15.5)') "lopp : ", iter, &
         &                             ", status : ", status(1:3), &
         &                             ", Res. : ", DBLE(v12(1))
         IF(status(1) < 0) EXIT
         !
      END DO
      !
      IF(status(2) == 0) THEN
         WRITE(*,*) "  Converged in iteration ", ABS(status(1))
      ELSE IF(status(2) == 1) THEN
         WRITE(*,*) "  Not Converged in iteration ", ABS(status(1))
      ELSE IF(status(2) == 2) THEN
         WRITE(*,*) "  Alpha becomes infinity", ABS(status(1))
      ELSE IF(status(2) == 3) THEN
         WRITE(*,*) "  Pi_seed becomes zero", ABS(status(1))
      ELSE IF(status(2) == 4) THEN
      WRITE(*,*) "  Residual & Shadow residual are orthogonal", &
      &          ABS(status(1))
      END IF
      iter_old = ABS(status(1))
      !
      ! Get these vectors for restart in the Next run
      !
      IF(itermax > 0) THEN
         !
         ALLOCATE(alpha(iter_old), beta(iter_old), r_l_save(nl,iter_old))
         !
         CALL komega_BiCG_getcoef(alpha, beta, z_seed, r_l_save)
         CALL komega_BiCG_getvec(v12,v14)
         !
         CALL output_restart(iter_old, z_seed, alpha, beta, &
         &                   r_l_save, v12, v14)
         !
         DEALLOCATE(alpha, beta, r_l_save)
         !     
      END IF
      !
    10 CONTINUE
      !
      ! Deallocate all intrinsic vectors
      !
      CALL komega_BiCG_finalize()
      !
      ! Output to a file
      !
      CALL output_result(nl, nz, z, x, r_l)
      !
      DEALLOCATE(v12, v2, v14, v4, r_l, x, z)
      !
      WRITE(*,*)
      WRITE(*,*) "#####  Done  #####"
      WRITE(*,*)
      !
    END PROGRAM my_prog

