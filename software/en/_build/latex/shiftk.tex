%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,dvipdfmx,openany,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Shiftk Documentation}
\date{May 03, 2020}
\release{2.0.0}
\author{kawamura}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{komega.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{shiftk_overview_en:overview}}\label{\detokenize{shiftk_overview_en::doc}}
This is document for the sample program which uses
K \(\omega\) library in the ISSP Math Library;
this program computes the Green’s function with \(K\omega\).
For the details of K \(\omega\) library, See
“\(K\omega\) manual” in this package.


\section{Calculation in this program}
\label{\detokenize{shiftk_overview_en:calculation-in-this-program}}
This program compute the Green’s function
\begin{equation*}
\begin{split}\begin{align}
G_{i}(z) =
\langle i | (z-{\hat H})^{-1}| i \rangle
\equiv
{\boldsymbol \varphi}_i^{*} \cdot (z-{\hat H})^{-1} {\boldsymbol \varphi}_i,
\end{align}\end{split}
\end{equation*}
where \(| i \rangle\) is a wavefunction,
\({\cal H}\) is the Hamiltonian, and
\(z\) is a complex frequency.
\begin{description}
\item[{\({\cal H}\) in the above equation is obtained by either the}] \leavevmode
following two ways:

\end{description}
\begin{itemize}
\item {} 
Input \({\cal H}\) as a file with the MatrixMarket format

\item {} 
Construct \({\cal H}\) as a Hamiltonian of the
Heisenberg model in this program.

\end{itemize}

In the computation of the Green’s function,
we use either the following two method according to the type
of \({\hat H}\) (a real\sphinxhyphen{} or a complex\sphinxhyphen{} number).
\begin{itemize}
\item {} 
\({\hat H}\) of real numbers : Shifted Bi\sphinxhyphen{}Conjugate Gradient(BiCG) method

\item {} 
\({\hat H}\) of complex numbers : Shifted Conjugate Orthogonal Conjugate Gradient(COCG) method

\end{itemize}


\chapter{License}
\label{\detokenize{shiftk_copy_en:license}}\label{\detokenize{shiftk_copy_en::doc}}
\sphinxstyleemphasis{© 2016\sphinxhyphen{} The University of Tokyo. All rights reserved.}

\begin{DUlineblock}{0em}
\item[] This software is developed under the support of
\item[] “\sphinxstyleemphasis{Project for advancement of software usability in materials science}” by The
\item[] Institute for Solid State Physics, The University of Tokyo.
\item[] 
\item[] This library is free software; you can redistribute it and/or
\item[] modify it under the terms of the GNU Lesser General Public
\item[] License as published by the Free Software Foundation; either
\item[] version 2.1 of the License, or (at your option) any later version.
\item[] This library is distributed in the hope that it will be useful,
\item[] but WITHOUT ANY WARRANTY; without even the implied warranty of
\item[] MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
\item[] Lesser General Public License for more details.
\item[] 
\item[] You should have received a copy of the GNU Lesser General Public
\item[] License along with this library; if not, write to the Free Software
\item[] Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111\sphinxhyphen{}1307 USA
\item[] 
\item[] For more details, See ‘COPYING.LESSER’ in the root directory of this library.
\end{DUlineblock}


\chapter{Prerequisite}
\label{\detokenize{shiftk_env_en:prerequisite}}\label{\detokenize{shiftk_env_en::doc}}\begin{itemize}
\item {} 
fortran compiler

\item {} 
K \(\omega\) library

\item {} 
BLAS, LAPACK

\item {} 
MPI library (Optional)

\end{itemize}


\chapter{Overall procedure}
\label{\detokenize{shiftk_flow_en:overall-procedure}}\label{\detokenize{shiftk_flow_en::doc}}
This program performs simulation as follows (See Fig. \ref{shiftk_flow_en:calcflow} ):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Read a input file for the numerical condition.

\item {} 
(Optional) Read input files for the Hamiltonian and the right hand side vector.

\item {} 
(Optional) Read a file for the restart (\(\alpha\), \(\beta\), residual vectors)

\item {} 
(Bi)CG iteration with \(K\omega\) library

\item {} 
Output results (Green’s function, residual vectors, \(\alpha\), \(\beta\))

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=8cm]{{flow_en}.png}
\caption{Figure 4: Schematic flow of the calculation of this program.}\label{\detokenize{shiftk_flow_en:id6}}\label{\detokenize{shiftk_flow_en:calcflow}}\end{figure}

We introduce the detailed procedure as follows.
The format of each file is written in {\hyperref[\detokenize{shiftk_format_en:fileformat}]{\sphinxcrossref{\DUrole{std,std-ref}{Format of files}}}}.


\section{Calculation from scratch}
\label{\detokenize{shiftk_flow_en:calculation-from-scratch}}

\subsection{Prepare input file}
\label{\detokenize{shiftk_flow_en:prepare-input-file}}
In this input file, we specify the frequency grid,
the maximum number of iteration, etc.

A example of this input file is shown as follow.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{filename}
  \PYG{n}{inham} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{invec} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{ham}
\PYG{n}{nsite} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{Jx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Jy} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Jz} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Dz} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{d0}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{cg}
  \PYG{n}{maxloops} \PYG{o}{=} \PYG{l+m+mi}{100}
  \PYG{n}{convfactor} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{dyn}
  \PYG{n}{calctype} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{normal}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{nomega} \PYG{o}{=} \PYG{l+m+mi}{100}
  \PYG{n}{omegamin} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{n}{d0}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{n}{d0}\PYG{p}{)}
  \PYG{n}{omegamax} \PYG{o}{=} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{n}{d0}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{n}{d0}\PYG{p}{)}
  \PYG{n}{outrestart} \PYG{o}{=} \PYG{o}{.}\PYG{n}{TRUE}\PYG{o}{.}
\PYG{o}{/}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{InHam}} is the file\sphinxhyphen{}name for the Hamiltonian in the MatrixMarket format,
\sphinxcode{\sphinxupquote{InVec}} is the file\sphinxhyphen{}name of the right hand side vector,
\sphinxcode{\sphinxupquote{NOmega}} is the number of frequencies where the dynamical Green’s function
is computed.
\sphinxcode{\sphinxupquote{OmegaMin}} is the lower limit of the frequency \(z\),
\sphinxcode{\sphinxupquote{OmegaMax}} is the upper limit of the frequency \(z\).
These complex frequencies must be written as “\sphinxcode{\sphinxupquote{(\{Real part\}, \{Imaginaly part\})}}”.
The frequency grid is defined as
\begin{equation*}
\begin{split}\begin{align}
\omega_n =  {\tt OmegaMin}
+ \frac{n-1}{{\tt NOmega}-1}({\tt OmegaMax} - {\tt OmegaMin}).
\end{align}\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{MaxLoops}} is the maximum number of iterations.
For the details of this input file, see {\hyperref[\detokenize{shiftk_format_en:modpara}]{\sphinxcrossref{\DUrole{std,std-ref}{“Namelist” file}}}}.
The string variable must be specified with two \sphinxcode{\sphinxupquote{\textquotesingle{}}} or \sphinxcode{\sphinxupquote{"}}.


\subsection{(Optional) Prepare input file for the Hamiltonian and RHS vector}
\label{\detokenize{shiftk_flow_en:optional-prepare-input-file-for-the-hamiltonian-and-rhs-vector}}
Prepare input files for the Hamiltonian (MatrixMarket format)
and right hand side vector.

An example of the file of the right hand side vector
is shown as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{256}
\PYG{l+m+mf}{0.01}    \PYG{l+m+mf}{0.0}
\PYG{l+m+mf}{0.05}    \PYG{l+m+mf}{0.0}
\PYG{l+m+mf}{0.1}     \PYG{l+m+mf}{0.0}
\PYG{p}{(}\PYG{k}{continue} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}

Details of the file format is written in
{\hyperref[\detokenize{shiftk_format_en:ham}]{\sphinxcrossref{\DUrole{std,std-ref}{“InHam” file}}}} and {\hyperref[\detokenize{shiftk_format_en:vec}]{\sphinxcrossref{\DUrole{std,std-ref}{“InVec” file}}}}.


\subsection{Launch}
\label{\detokenize{shiftk_flow_en:launch}}
Execute a program \sphinxcode{\sphinxupquote{ShiftK.out}} with a namelist file \sphinxcode{\sphinxupquote{namelist.def}}
as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ShiftK.out namelist.def
\end{sphinxVerbatim}


\subsection{Output}
\label{\detokenize{shiftk_flow_en:output}}
The following files are generated in \sphinxcode{\sphinxupquote{output/}} directory (this directory is
also generated by this program).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TriDiagComp}\PYG{o}{.}\PYG{n}{dat}\PYG{p}{,} \PYG{n}{ResVec}\PYG{o}{.}\PYG{n}{dat}\PYG{p}{,} \PYG{n}{dynamicalG}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

where
\sphinxcode{\sphinxupquote{TriDiagComp.dat}} contains the parameters for the restart,
\sphinxcode{\sphinxupquote{ResVec.dat}} contains the residual vector,
\sphinxcode{\sphinxupquote{dynamicalG.dat}} contains the dynamical Green’s function.
The format of these file is written in
{\hyperref[\detokenize{shiftk_format_en:revec}]{\sphinxcrossref{\DUrole{std,std-ref}{Residual vector}}}} \sphinxhyphen{} {\hyperref[\detokenize{shiftk_format_en:dynamicalg}]{\sphinxcrossref{\DUrole{std,std-ref}{Dynamical Green’s function}}}}.


\section{Catch up}
\label{\detokenize{shiftk_flow_en:catch-up}}
Compute the Green’s function at the different frequency by using the information
of \sphinxcode{\sphinxupquote{output/TriDiagComp.dat}} that are generated in the previous run.
This calculation does not require the matrix\sphinxhyphen{}vector product.


\subsection{Modify the namelist file}
\label{\detokenize{shiftk_flow_en:modify-the-namelist-file}}
Change \sphinxcode{\sphinxupquote{calctype}} parameter in the file \sphinxcode{\sphinxupquote{namelist.def}}
from \sphinxcode{\sphinxupquote{"normal"}} to \sphinxcode{\sphinxupquote{"recalc"}}.
\sphinxcode{\sphinxupquote{OmegaMin}}, \sphinxcode{\sphinxupquote{OmegaMax}}, etc. can be modified.


\subsection{Launch}
\label{\detokenize{shiftk_flow_en:id1}}
Execute a program \sphinxcode{\sphinxupquote{ShiftK.out}} with a namelist file \sphinxcode{\sphinxupquote{namelist.def}}
as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ShiftK.out namelist.def
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{output/dynamicalG.dat}} will be overwritten.


\subsection{Output}
\label{\detokenize{shiftk_flow_en:id2}}
The same output files as the previous section are generated.


\section{Restart}
\label{\detokenize{shiftk_flow_en:restart}}
Compute the Green’s function at the different frequency by using the information
of \sphinxcode{\sphinxupquote{output/TriDiagComp.dat}} and \sphinxcode{\sphinxupquote{output/ResVec.dat}}
that are generated in the previous run.


\subsection{Modify the namelist file}
\label{\detokenize{shiftk_flow_en:id3}}
Change \sphinxcode{\sphinxupquote{calctype}} parameter in the file \sphinxcode{\sphinxupquote{namelist.def}}
from \sphinxcode{\sphinxupquote{"normal"}} to \sphinxcode{\sphinxupquote{"restart"}}.
\sphinxcode{\sphinxupquote{OmegaMin}}, \sphinxcode{\sphinxupquote{OmegaMax}}, etc. can be modified.
Parameters \sphinxcode{\sphinxupquote{InHam}} ,  \sphinxcode{\sphinxupquote{InVec}}, and the files of the Hamiltonian
and RHS vector can not be modified.


\subsection{Launch}
\label{\detokenize{shiftk_flow_en:id4}}
Execute a program \sphinxcode{\sphinxupquote{ShiftK.out}} with a namelist file \sphinxcode{\sphinxupquote{namelist.def}}
as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ShiftK.out namelist.def
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{output/dynamicalG.dat}} will be overwritten.


\subsection{Output}
\label{\detokenize{shiftk_flow_en:id5}}
The following files are generated (or are overwritten) in \sphinxcode{\sphinxupquote{output/}} directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TriDiagComp}\PYG{o}{.}\PYG{n}{dat}\PYG{p}{,} \PYG{n}{ResVec}\PYG{o}{.}\PYG{n}{dat}\PYG{p}{,} \PYG{n}{dynamicalG}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

where
\sphinxcode{\sphinxupquote{TriDiagComp.dat}} contains the parameters for the restart,
\sphinxcode{\sphinxupquote{ResVec.dat}} contains the residual vector,
\sphinxcode{\sphinxupquote{dynamicalG.dat}} contains the dynamical Green’s function.
The format of these file is written in
{\hyperref[\detokenize{shiftk_format_en:revec}]{\sphinxcrossref{\DUrole{std,std-ref}{Residual vector}}}} \sphinxhyphen{} {\hyperref[\detokenize{shiftk_format_en:dynamicalg}]{\sphinxcrossref{\DUrole{std,std-ref}{Dynamical Green’s function}}}}.


\chapter{Format of files}
\label{\detokenize{shiftk_format_en:format-of-files}}\label{\detokenize{shiftk_format_en:fileformat}}\label{\detokenize{shiftk_format_en::doc}}

\section{Input files}
\label{\detokenize{shiftk_format_en:input-files}}

\subsection{“Namelist” file}
\label{\detokenize{shiftk_format_en:namelist-file}}\label{\detokenize{shiftk_format_en:modpara}}
This file has four namelist (\sphinxcode{\sphinxupquote{filename}}, \sphinxcode{\sphinxupquote{ham}}, \sphinxcode{\sphinxupquote{cg}}, \sphinxcode{\sphinxupquote{dyn}}).
For the details of the namelist of fortran, see some books and Web page for fortran.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZam{}}\PYG{n}{filename}
  \PYG{n}{inham} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{invec} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{ham}
\PYG{n}{nsite} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{Jx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Jy} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Jz} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{d0}
\PYG{n}{Dz} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{d0}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{cg}
  \PYG{n}{maxloops} \PYG{o}{=} \PYG{l+m+mi}{100}
  \PYG{n}{convfactor} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{o}{/}
\PYG{o}{\PYGZam{}}\PYG{n}{dyn}
  \PYG{n}{calctype} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{normal}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{nomega} \PYG{o}{=} \PYG{l+m+mi}{100}
  \PYG{n}{omegamin} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{n}{d0}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{n}{d0}\PYG{p}{)}
  \PYG{n}{omegamax} \PYG{o}{=} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{n}{d0}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{n}{d0}\PYG{p}{)}
  \PYG{n}{outrestart} \PYG{o}{=} \PYG{o}{.}\PYG{n}{TRUE}\PYG{o}{.}
\PYG{o}{/}
\end{sphinxVerbatim}

In the namelist \sphinxtitleref{“filename”\textasciigrave{}}, we specify the file names of the
Hamiltonian and the RHS vector.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{InHam}}

\sphinxstylestrong{Type :} string (default: \sphinxcode{\sphinxupquote{""}})

\sphinxstylestrong{Description :}
The name of the file for the Hamiltonian in the MatrixMarket format
(full path or relative path).
If this parameter is not specified,
the Hamiltonian of the 1D spin chain is generated
with the parameters in \sphinxcode{\sphinxupquote{ham}} namelist.

\item {} 
\sphinxcode{\sphinxupquote{InVec}}

\sphinxstylestrong{Type :} string (default: \sphinxcode{\sphinxupquote{""}})

\sphinxstylestrong{Description :}
The name of the file for the right hand side vector.
If this parameter is not specified,
the RHS vector is generated as follows:
First the ground\sphinxhyphen{}state vector is computed.
Then RHS vector is calculated by operating
\({\hat S}_{1 z}\) (\(z\) component of the spin at site 1)
to the ground\sphinxhyphen{}state vector.
Therefore, we assume the computed system is
the one\sphinxhyphen{}dimensional spin chain.

\end{itemize}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{"ham"}} namelist is read only when}] \leavevmode
\sphinxcode{\sphinxupquote{InHam}} is not specified.
The parameters in this namelist are used to generate
the Hamiltonian of the one\sphinxhyphen{}dimensional spin chain (See Fig. \ref{shiftk_format_en:spin})

\end{description}
\begin{equation*}
\begin{split}\begin{align}
  {\hat H} = \sum_{i}
  \left(
  \begin{matrix}
    {\hat S}_{i x} & {\hat S}_{i y} & {\hat S}_{i z}
  \end{matrix}
  \right)
  \left(
  \begin{matrix}
    J_x & D_z & 0 \\
    -D_z & J_y & 0 \\
    0 & 0 & J_z
  \end{matrix}
  \right)
  \left(
  \begin{matrix}
    {\hat S}_{i+1 x} \ {\hat S}_{i+1 y} \ {\hat S}_{i+1 z}
  \end{matrix}
  \right).
  \end{align}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{spin}.png}
\caption{Figure 2: Schematic picture of the one\sphinxhyphen{}dimensional spin chain.}\label{\detokenize{shiftk_format_en:id2}}\label{\detokenize{shiftk_format_en:spin}}\end{figure}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nsite}}

\sphinxstylestrong{Type :} int (default: \sphinxcode{\sphinxupquote{4}})

\sphinxstylestrong{Description :}
The number of sites in the 1D spin chain model.

\item {} 
\sphinxcode{\sphinxupquote{Jx}}

\sphinxstylestrong{Type :} double (default: \sphinxcode{\sphinxupquote{1.0}})

\sphinxstylestrong{Description :} \(J_x\) for the Heisenberg model.

\item {} 
\sphinxcode{\sphinxupquote{Jy}}

\sphinxstylestrong{Type :} double (default: \sphinxcode{\sphinxupquote{1.0}})

\sphinxstylestrong{Description :} \(J_y\) for the Heisenberg model.

\item {} 
\sphinxcode{\sphinxupquote{Jz}}

\sphinxstylestrong{Type :} double (default: \sphinxcode{\sphinxupquote{1.0}})

\sphinxstylestrong{Description :} \(J_z\) for the Heisenberg model.

\item {} 
\sphinxcode{\sphinxupquote{Dz}}

\sphinxstylestrong{Type :} double (default: \sphinxcode{\sphinxupquote{0.0}})

\sphinxstylestrong{Description :}
The parameter of the Dzyaloshinskii\sphinxhyphen{}Moriya interaction (\(D_z\)).

\end{itemize}

\sphinxcode{\sphinxupquote{cg}} namelist has parameters
for specifying the numerical condition for the
(Bi)Conjugate\sphinxhyphen{}gradient method.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MaxLoops}}

\sphinxstylestrong{Type :} int (default: the dimension of the Hamiltonian)

\sphinxstylestrong{Description :} The maximum number of iterations.

\item {} 
\sphinxcode{\sphinxupquote{Convfactor}}

\sphinxstylestrong{Type :} int (default: \sphinxcode{\sphinxupquote{8}})

\sphinxstylestrong{Description :} Convergence threshold.
If the 2\sphinxhyphen{}norm of the residual vector becomes smaller than
\(10^{-{\tt Convfactor}}\), the calculation finishes.

\end{itemize}

\sphinxcode{\sphinxupquote{dyn}} has the parameters for the computation of the spectrum.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{OmegaMin}}

\sphinxstylestrong{Type :} Complex (default: If \sphinxcode{\sphinxupquote{invec}} is not specified,
the real part of it becomes the smallest eigenvalue,
and the imaginary part of it becomes \(\times0.01\) times
the difference between the largest\sphinxhyphen{} and the smallest\sphinxhyphen{} eigenvalue.
If \sphinxcode{\sphinxupquote{invec}} is specified, the default value becomes \sphinxcode{\sphinxupquote{(0.0, 0.01)}})

\sphinxstylestrong{Description :} The smallest frequency.

\item {} 
\sphinxcode{\sphinxupquote{OmegaMax}}

\sphinxstylestrong{Type :} Complex (default: If \sphinxcode{\sphinxupquote{invec}} is not specified,
the real part of it becomes the largest eigenvalue,
and the imaginary part of it becomes \(\times0.01\) times
the difference between the largest\sphinxhyphen{} and the smallest\sphinxhyphen{} eigenvalue.
If \sphinxcode{\sphinxupquote{invec}} is specified, the default value becomes \sphinxcode{\sphinxupquote{(1.0, 0.01)}})

\sphinxstylestrong{Description :} The largest frequency.

\item {} 
\sphinxcode{\sphinxupquote{NOmega}}

\sphinxstylestrong{Type :} int (default: \sphinxcode{\sphinxupquote{10}})

\sphinxstylestrong{Description :} The number of frequencies.

\item {} 
\sphinxcode{\sphinxupquote{outrestart}}

\sphinxstylestrong{Type :} Logical (default: \sphinxcode{\sphinxupquote{.FALSE.}})

\sphinxstylestrong{Description :}
Whether data for restart will be written (\sphinxcode{\sphinxupquote{.TRUE.}}) or not (\sphinxcode{\sphinxupquote{.FALSE.}}).

\item {} 
\sphinxcode{\sphinxupquote{calctype}}

\sphinxstylestrong{Type :}
String.  Choose from \sphinxcode{\sphinxupquote{"normal"}}, \sphinxcode{\sphinxupquote{"recalc"}}, \sphinxcode{\sphinxupquote{"restart"}}.
(default: \sphinxcode{\sphinxupquote{"normal"}})

\sphinxstylestrong{Description :}
\sphinxcode{\sphinxupquote{"normal"}} for computing with the Krylov subspace from scratch.
\sphinxcode{\sphinxupquote{"recalc"}} for computing with the Krylov subspace
generated in the previous calculation.
In this case, the matrix\sphinxhyphen{}vector product is not performed.
The convergence is not guaranteed.
\sphinxcode{\sphinxupquote{"restart"}} for restarting the calculation from the
previous run.
In this case, the calculation continues until
the convergence is achieved or the number of iteration becomes \sphinxcode{\sphinxupquote{MaxLoops}}.

\end{itemize}


\subsection{“InHam” file}
\label{\detokenize{shiftk_format_en:inham-file}}\label{\detokenize{shiftk_format_en:ham}}
The Hamiltonian is written in the MatrixMarket format.

Example of the “InHam” file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n}{MatrixMarket} \PYG{n}{matrix} \PYG{n}{coordinate} \PYG{n+nb}{complex} \PYG{n}{hermitian}
\PYG{l+m+mi}{16} \PYG{l+m+mi}{16} \PYG{l+m+mi}{20}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mf}{1.000000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{6} \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{6} \PYG{l+m+mi}{6} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.000000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{7} \PYG{l+m+mi}{6} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{9} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{9} \PYG{l+m+mi}{5} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{10} \PYG{l+m+mi}{6} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{11} \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{11} \PYG{l+m+mi}{7} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{11} \PYG{l+m+mi}{10} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{11} \PYG{l+m+mi}{11} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.000000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{12} \PYG{l+m+mi}{8} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{13} \PYG{l+m+mi}{6} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{13} \PYG{l+m+mi}{11} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{14} \PYG{l+m+mi}{12} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{15} \PYG{l+m+mi}{8} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{15} \PYG{l+m+mi}{14} \PYG{l+m+mf}{0.500000} \PYG{l+m+mf}{0.000000}
\PYG{l+m+mi}{16} \PYG{l+m+mi}{16} \PYG{l+m+mf}{1.000000} \PYG{l+m+mf}{0.000000}
\end{sphinxVerbatim}
\begin{description}
\item[{First row:}] \leavevmode
Arbitrary string (such as comment).

\item[{Second row:}] \leavevmode
The number of rows, columns, and non\sphinxhyphen{}zero elements
(in \sphinxstylestrong{the lower triangle part}).

\item[{Third row \sphinxhyphen{} End:}] \leavevmode
The row\sphinxhyphen{} and the column\sphinxhyphen{} index, and
the real\sphinxhyphen{} and imaginary\sphinxhyphen{} part of the non\sphinxhyphen{}zero element
(in \sphinxstylestrong{the lower triangle part}).

\end{description}


\subsection{“InVec” file}
\label{\detokenize{shiftk_format_en:invec-file}}\label{\detokenize{shiftk_format_en:vec}}
Right hand side vector is contained.

Example of the “InVec” file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8192}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.01}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.001}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
First row: {[} int01 {]}

\sphinxstylestrong{Type :} int

\sphinxstylestrong{Description :}
The dimension of the Hilbert space.
It must be the same as the dimension of the Hamiltonian.

\item {} 
Second row \sphinxhyphen{} End:
{[} double01 {]} {[} double02 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} The element of the RHS vector.
{[} double01 {]} is the real part,
and {[} double02 {]} is the imaginary part.

\end{itemize}


\subsection{Coefficients for restart}
\label{\detokenize{shiftk_format_en:coefficients-for-restart}}\label{\detokenize{shiftk_format_en:recoeff}}
The coefficient \(\alpha\) and \(\beta\)
are contained.

The name of the generated file is \sphinxcode{\sphinxupquote{TriDiagComp.dat}}.

The example of this file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1000}
\PYG{l+m+mf}{1.0} \PYG{l+m+mf}{0.0}
\PYG{l+m+mf}{0.1} \PYG{l+m+mi}{0} \PYG{l+m+mf}{0.01}  \PYG{l+m+mi}{0}
\PYG{l+m+mf}{0.2} \PYG{l+m+mi}{0} \PYG{l+m+mf}{0.021} \PYG{l+m+mi}{0}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{l+m+mf}{2.1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}
\PYG{l+m+mf}{3.1} \PYG{l+m+mf}{4.0}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
First row: {[} int01 {]}

\sphinxstylestrong{Type :} int

\sphinxstylestrong{Description :}
The length of \(\alpha, \beta\).
It is the same as the number of iterations in the previous run.

\item {} 
Second row: {[} double01 {]} {[} double02 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} The seed frequency \(z_{\rm seed}\).
{[} double01 {]} is the real part of \(z_{\rm seed}\), and
{[} double02 {]} is the imaginary par of \(z_{\rm seed}\).

\item {} 
Third row \sphinxhyphen{} 2 + {[} int01 {]}th row:
{[} double03 {]} {[} double04 {]} {[} double05 {]} {[} double06 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} \(\alpha, \beta\) at the each iteration.
{[} double03 {]} is the real part of \(\alpha\),
{[} double04 {]} is the imaginary part of \(\alpha\),
{[} double05 {]} is the real part of \(\beta\),
{[} double06 {]} is the imaginary part of \(\beta\).

\item {} 
3 + {[} int01 {]}th row \sphinxhyphen{}
2 + \(2\times[\) int01 {]}th row:
{[} double07 {]} {[} double08 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} The product of the RHS vector and
the residual vector at the each iteration.
{[} double07 {]} is the real part of it, and
{[} double08 {]} is the imaginary part of it.

\end{itemize}


\subsection{Residual vector}
\label{\detokenize{shiftk_format_en:residual-vector}}\label{\detokenize{shiftk_format_en:revec}}
The residual vector is contained for the restart.
The file name is \sphinxcode{\sphinxupquote{ResVec.dat}}.

Example of this file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8192}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.01}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.001}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.01}
\PYG{l+m+mf}{0.02} \PYG{l+m+mf}{0.001}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Only} \PYG{k}{for} \PYG{n}{BiCG}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
First row: {[} int01 {]}

\sphinxstylestrong{Type :} int

\sphinxstylestrong{Description :} The dimension of the Hilbert space.

\item {} 
Second row \sphinxhyphen{} 1 + {[} int01 {]}th row:
{[} double01 {]} {[} double02 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} Each element of the residual vector.
{[} double01 {]} is the real part of it, and
{[} double02 {]} is the imaginary part of it.

\item {} 
Third row \sphinxhyphen{} 1 + 2 \(\times\) {[} int01 {]}th row:
{[} double03 {]} {[} double04 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :}
(Only when the Hamiltonian is a complex matrix)
Each element of the shadow residual vector.
{[} double03 {]} is the real part of it,
{[} double04 {]} is the imaginary part of it.

\end{itemize}


\section{Output file}
\label{\detokenize{shiftk_format_en:output-file}}

\subsection{Coefficient for restart}
\label{\detokenize{shiftk_format_en:coefficient-for-restart}}
The format is the same as {\hyperref[\detokenize{shiftk_format_en:recoeff}]{\sphinxcrossref{\DUrole{std,std-ref}{Coefficients for restart}}}}.


\subsection{Residual vector}
\label{\detokenize{shiftk_format_en:id1}}
The format is the same as {\hyperref[\detokenize{shiftk_format_en:revec}]{\sphinxcrossref{\DUrole{std,std-ref}{Residual vector}}}}.


\subsection{Dynamical Green’s function}
\label{\detokenize{shiftk_format_en:dynamical-green-s-function}}\label{\detokenize{shiftk_format_en:dynamicalg}}
The dynamical Green’s function is contained.

Example of this file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{l+m+mf}{0.001} \PYG{l+m+mf}{0.001} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0001}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.8} \PYG{l+m+mf}{0.001} \PYG{l+m+mf}{0.0012} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0002}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.6} \PYG{l+m+mf}{0.001} \PYG{l+m+mf}{0.0014} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0003}
\PYG{p}{(}\PYG{k}{continue}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
First row \sphinxhyphen{} END:
{[} double01 {]} {[} double02 {]} {[} double03 {]} {[} double04 {]}
\begin{itemize}
\item {} 
{[} double01 {]}, {[} double02 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} The real\sphinxhyphen{} ({[} double01 {]})
and the imaginary\sphinxhyphen{} ({[} double02 {]}) part of the frequency.

\item {} 
{[} double03 {]}, {[} double04 {]}

\sphinxstylestrong{Type :} double

\sphinxstylestrong{Description :} The dynamical Green’s function.
{[} double01 {]} is the real part of it, and
{[} double02 {]} is the imaginary part of it.

\end{itemize}

\end{itemize}


\chapter{Contact}
\label{\detokenize{shiftk_contact_en:contact}}\label{\detokenize{shiftk_contact_en::doc}}
If you have any comments, questions, bug reports etc. about this program,
please contact to the main developer (Mitsuaki Kawamura) by
sending the e\sphinxhyphen{}mail (the address is shown below).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkawamura\PYGZus{}at\PYGZus{}issp}\PYG{o}{.}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{tokyo}\PYG{o}{.}\PYG{n}{ac}\PYG{o}{.}\PYG{n}{jp}
\end{sphinxVerbatim}

Please change \sphinxcode{\sphinxupquote{\_at\_}} into \sphinxcode{\sphinxupquote{@}}, when you will send the e\sphinxhyphen{}mail.



\renewcommand{\indexname}{Index}
\printindex
\end{document}