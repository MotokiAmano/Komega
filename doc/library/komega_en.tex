%
% ISSP Math Library - A library for solving linear systems in materials science
% Copyright (C) 2016 Mitsuaki Kawamura
% 
% This library is free software; you can redistribute it and/or
% modify it under the terms of the GNU Lesser General Public
% License as published by the Free Software Foundation; either
% version 2.1 of the License, or (at your option) any later version.
% 
% This library is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
% し
% You should have received a copy of the GNU Lesser General Public
% License along with this library; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
% 
% For more details, See `COPYING.LESSER' in the root directory of this library.
%
\documentclass[12pt,titlepage]{article}
%\documentclass[12pt,titlepage]{article}
%\usepackage[whole]{bxcjkjatype}
%\setminchofont{ipaexm.ttf}
%\setgothicfont{ipaexg.ttf}
%\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{bm}% bold math
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage {framed,color}
\usepackage[dvipdfmx]{hyperref}

%
%\pagestyle{fancy}
%
\topmargin=-30mm
\textheight=27cm
\textwidth=17cm
\oddsidemargin=-0.04 cm
\evensidemargin=-1.04cm
%1inchi = 2.54cm
%A4 = 21.0 * 29.7
%
\makeatletter
\renewenvironment{leftbar}{%
%  \def\FrameCommand{\vrule width 3pt \hspace{10pt}}%  デフォルトの線の太さは3pt
  \def\FrameCommand{\vrule width 1pt \hspace{0pt}}% 
  \MakeFramed {\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\makeatother

\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{lmodern}
\usepackage{listings}
\lstset{language=[90]Fortran,
  basicstyle=\ttfamily\small,
  keywordstyle=\color[rgb]{0,0,0.7},
  commentstyle=\color[rgb]{0.5,0,0},
  morecomment=[l]{!\ }% Comment only with space after !
}



\begin{document}
%
% Cover
%
\title{User guide: $K(\omega)$ ver. 1.0}
\author{{\it \copyright 2016- The University of Tokyo}\\
{\it  All rights reserved.}
}
\date{Dec. 12, 2016}
\maketitle
%

%
% Contents
%
\tableofcontents

\section{Overview}
This document is a manual for $K(\omega)$ which is the library to solve the shifted linear equation within the Krylov subspace.
This library provides routines to solve the following shifted linear equation (with the projection), 
\begin{align}
  G_{i j}(z) = \langle i | (z {\hat I} -{\hat H})^{-1}| j \rangle \equiv 
  {\boldsymbol \varphi}_i^{*} \cdot (z{\hat I}-{\hat H})^{-1} {\boldsymbol \varphi}_j.
  \label{ShiftedEquatin}
\end{align}
The source codes of $K(\omega)$ is written in FORTRAN.
To solve the equations, the BLAS Level 1 routines are used.
\section{Copyright}

\noindent
{\it \copyright 2016- The University of Tokyo} {\it  All rights reserved.}
This software is developed under the support of ``{\it Project for advancement of software usability in materials science }" by The Institute for Solid State Physics, The University of Tokyo. 
%ISSP Math Library - A library for solving linear systems in materials science \\
%Copyright (C) 2016 Mitsuaki Kawamura \\
 \\
This library is free software; you can redistribute it and/or \\
modify it under the terms of the GNU Lesser General Public \\
License as published by the Free Software Foundation; either \\
version 2.1 of the License, or (at your option) any later version. \\
 \\
This library is distributed in the hope that it will be useful, \\
but WITHOUT ANY WARRANTY; without even the implied warranty of \\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU \\
Lesser General Public License for more details. \\
 \\
You should have received a copy of the GNU Lesser General Public \\
License along with this library; if not, write to the Free Software \\
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \\
 \\
For more details, See `COPYING.LESSER' in the root directory of this library.

\section{Algorithm}

This library provides the four kinds of numerical solvers.
The kind of solvers is selected under the condition whether the Hamiltonian ${\hat H}$ and/or the frequency $z$ are complex or real number. It is noted that ${\hat H}$ must be Hermitian (symmetric) for complex (real) number.  

\begin{itemize}
\item (${\hat H}$, $z$) = (complex, complex): \\
Shifted Bi-Conjugate Gradient(BiCG) method \cite{BiCG} or Shifted Conjugate Orthogonal Conjugate Gradient(COCG) method \cite{COCG}
\item  (${\hat H}$, $z$) = (real, complex):\\
Shifted Conjugate Orthogonal Conjugate Gradient(COCG) method \cite{COCG}
\item  (${\hat H}$, $z$) = (complex, real):\\
Shifted Conjugate Gradient(CG) method (using complex vector)
\item  (${\hat H}$, $z$) = (real, real):\\
Shifted Conjugate Gradient(CG) method (using real vector)
\end{itemize}
For above methods, seed switching
\textcolor{red}{(文献を引く)}
is adopted.
Hereafter, the number of the left (right) side vector, $ {\boldsymbol \varphi}_{i}$ ($ {\boldsymbol \varphi}_{j}$), in Eq.~(\ref{ShiftedEquatin}) is indicated by $N_L$ ($N_R$). The details of each algorithm are written as follows.
%\newpage
\subsection{Shifted BiCG method with seed switching technique}

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, ${\tilde {\boldsymbol r}} = $ an arbitrary vector,
${\boldsymbol r}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$Seed equation
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\tilde {\boldsymbol r}}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\tilde {\boldsymbol r}}^*\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$Shifted equation
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed}^* {\hat I} - {\hat H}) {\tilde {\boldsymbol r}},\;
{\boldsymbol q} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\tilde {\boldsymbol r}}
- \alpha^* {\boldsymbol q} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\tilde {\boldsymbol r}}^{\rm old},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}},\; {\tilde {\boldsymbol r}} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
Search $k$ which gives the minimum value of $|\pi_k|$.
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old},\; 
{\tilde {\boldsymbol r}} = {\tilde {\boldsymbol r}} / \pi_{\rm seed}^{ *},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} / \pi_{\rm seed}^{{\rm old}*}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Shifted COCG method with seed switching technique}

This method is obtained by 
${\tilde {\boldsymbol r}} = {\boldsymbol r}^*,\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{{\rm old}*}$
in BiCG method.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$Seed equation
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r} \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$Shifted equation
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
Search $k$ which gives the minimum value of $|\pi_k|$.
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Shifted CG method with seed switching technique}
This method is obtained by 
${\tilde {\boldsymbol r}} = {\boldsymbol r},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{\rm old}$
in BiCG method.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$Seed equation
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}^* \cdot {\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$Shifted equation
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\left(\frac{\pi^{\rm old}_k}{\pi_k } \right)^2 \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
Search $k$ which gives the minimum value of $|\pi_k|$.
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / {\pi_{\rm seed}^{\rm old}}^2$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old}/\pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

\section{The schematic workflow of libraries in the program}

In the following description, the loop for $N_R$ is omitted for simplicity and 
instead of $G_{i j}(z_k)$,
the $N_L$-dimensional vector ${\bf x}_{k}$ is obtained by using the library.

The essential procedures to use the library.
\begin{itemize}
\item Give the vector size $N_H$ corresponding to the size of the Hilbert space and the number of the frequency $z$.
\item Allocate the two vectors (in the case of BiCG method, four vectors) with the size of $N_H$.
\item Give the function for the Hamiltonian-vector production.
\item Allocate the solution vectors. It is noted that the number of the solution vectors is not always equal to $N_H \times N_z$. In fact, the number in the previous section is $N_L \times N_z$. 
In this case, the (bi-)conjugate gradient vector ${{\bf p}_k}$ is the vector with $N_L$-dimension and $N_z$ array.
The transformation of the dimension of the residual vector from $N_H$ to $N_L$ must be done explicitly.
%この時(双)共役勾配ベクトル${{\bf p}_k}$も
%$N_z$個の$N_L$次元のベクトルである.
%  $N_H$次元の残差ベクトルを$N_L$次元へ変換するところはユーザーが行う.
  \begin{align}
    {\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
    {\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
  \end{align}
\item Conserve $\alpha, \beta, {\bf r}^{\rm L}$ at each iteration 
and to use the above vectors later, set the maximum number of iterations \verb|itermax|.
\end{itemize}
\newpage

The names of the routines is defined as follows. 
\begin{itemize}
\item \verb|BiCG_init|, \verb|COCG_init|, \verb|CG_C_init|, \verb|CG_R_init|

Set the initial conditions such as the allocation of variables used in the library. 
%ライブラリ内部で使う(ユーザーの目に触れない)変数のAllocateや初期値設定を行う.

\item \verb|BiCG_update|, \verb|COCG_update|, \verb|CG_C_update|, \verb|CG_R_update|

These routines are called in the iteration to update the solution vectors.
%Iteration の中で呼び出される. 解ベクトル群の更新等を行う.

%%\item \verb|BiCG_update1|, \verb|BiCG_update2|
%%
%%BiCGで, ベクトルの本数を1本減らしてメモリを節約したいときに\verb|BiCG_update|の代わりに用いる.
%%この場合には\verb|BiCG_init|の代わりに\verb|BiCG_init0|を使う.

\item \verb|BiCG_finalize|, \verb|COCG_finalize|, \verb|CG_C_finalize|, \verb|CG_R_finalize|

Release the allocated vectors in the library. 
%Allocateしたライブラリ内部ベクトルを開放する.

\item \verb|BiCG_getcoef|, \verb|COCG_getcoef|, \verb|CG_C_getcoef|, \verb|CG_R_getcoef|

Get the $\alpha$, $\beta$, $z_{\rm seed}$, ${\bf r}^{\rm L}$ conserved at each iteration.
%各iterationで保存しておいた$\alpha$, $\beta$, $z_{\rm seed}$, ${\bf r}^{\rm L}$を取り出す.

\item \verb|BiCG_getvec|, \verb|COCG_getvec|, \verb|CG_C_getvec|, \verb|CG_R_getvec|

Get the vectors
${\boldsymbol r}$, ${\boldsymbol r}^{\rm old}$, 
${\tilde {\boldsymbol r}}$, ${\tilde {\boldsymbol r}}^{\rm old}$.

\item \verb|BiCG_restart|, \verb|COCG_restart|, \verb|CG_C_restart|, \verb|CG_R_restart|

\textcolor{red}{
Recalculate $G_{i j}(z)$ for new frequencies $z_{new}$ by using the conserved information such as $\alpha$.
The restart calculation can be also selected 
when ${\boldsymbol r}$, ${\boldsymbol r}^{\rm old}$, 
${\tilde {\boldsymbol r}}$, ${\tilde {\boldsymbol r}}^{\rm old}$ are input.
}

%保存しておいた$\alpha$等を用いて, 新規の$z$での計算を行う.
%${\boldsymbol r}$等も有る場合には
%\verb|BiCG_init|, \verb|COCG_init|, \verb|CG_C_init|, \verb|CG_R_init|
%の代わりに用いてリスタートすることもできる.

\end{itemize}

\subsection{The schematic workflow of shifted BiCG library}%%(メモリ節約なし)}

\noindent
Allocate ${\boldsymbol v}_{1 2}$, ${\boldsymbol v}_{1 3}$, 
${\boldsymbol v}_2$, ${\boldsymbol v}_3$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|komega_BiCG_init(N_H, N_L, N_z, v_2, v_4, x, z, itermax)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_3$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
  Restore the arrays to conserve $\alpha$, $\beta$, ${\bf r}^{\rm L}$ when  \verb|itermax|$\neq$\verb|0|.
%  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_4 = {\boldsymbol v}_2^*$(n) (n is an arbitrary number),
  ${\boldsymbol v}_3 = {\boldsymbol v}_5 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$,
  ${\boldsymbol v}_4 \equiv {\tilde {\boldsymbol r}}$, 
  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
  \\
  \verb|komega_BiCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2$, 
${\boldsymbol v}_{1 4} = {\hat H} {\boldsymbol v}_4$  
$ [({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4}) = {\hat H}
  ({\boldsymbol v}_2, {\boldsymbol v}_4)]$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|komega_BiCG_update(v_12, v_14, v_2, v_4, x, r_small)| start
  \\\hspace{1.0cm}
  $\circ$Seed equation
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_4^* \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}$, 
  ${\boldsymbol v}_{1 4} = z_{\rm seed}^* {\boldsymbol v}_4 - {\boldsymbol v}_{1 4}$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$Shifted equation
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$, 
  ${\boldsymbol v}_3 = {\boldsymbol v}_2,\;
  {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 4} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\boldsymbol v}_4
  - \alpha^* {\boldsymbol v}_{1 4} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5$, 
  ${\boldsymbol v}_5 = {\boldsymbol v}_4,\; 
  {\boldsymbol v}_4 = {\boldsymbol v}_{1 4}$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  Search $k$ which gives the minimum value of $|\pi_k|$.
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$,
  ${\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{*}$, 
  ${\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
\verb|komega_BiCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
\noindent
\verb|komega_BiCG_finalize| start
\\ \hspace{0.5cm}
Deallocate ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
\\
\verb|komega_BiCG_finalize| finish
\end{leftbar}

\subsection{The schematic workflow of shifted COCG library}

\noindent
Allocate ${\boldsymbol v}_1$, ${\boldsymbol v}_2$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
\\ 
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_init(N_H, N_L, N_z, x, z)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
    Restore the arrays to conserve $\alpha$, $\beta$, ${\bf r}^{\rm L}$ when  \verb|itermax|$\neq$\verb|0|.
%  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_3 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$. )
  \\
  \verb|COCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|COCG_update(v_1, v_2, x, p, r_small)| start
  \\\hspace{1.0cm}
  $\circ$Seed equation
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$Shifted equation
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_3 = {\boldsymbol v}_2$,
  ${\boldsymbol v}_2 = {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  Search $k$ which gives the minimum value of $|\pi_k|$.
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
  \verb|COCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_finalize| start
  \\ \hspace{0.5cm}
  Deallocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\
  \verb|COCG_finalize| finish
\end{leftbar}
\vspace{-1em}

\subsection{The schematic workflow of shifted CG library}

The workflow is same as that of shifted COCG library.

\section{Usage}

The calculation is done to utilize functions by the following procedures.
%各ライブラリともユーザーはライブラリ名および型を指定し, 
\begin{itemize}
\item Initialization (init function)
\item Update (update function)
\item Output numerical results (call getcoef, getvec functions and output informations)
\item Finalization (finalize function)
\end{itemize}
%の手順で関数を使用することで, 計算が実施される. 

The restart calculation can be done by the following procedures.
%なお, リスタートを行う場合には
\begin{itemize}
\item Initialization(restart function)
\item Update (update function)
\item Output numerical results (call getcoef, getvec functions and output informations)
\item Finalization (finalize function)
\end{itemize}
%の手順で実行する.

For FORTRAN, the modules can be called by 
%fortran から呼び出すときには
\begin{verbatim}
  USE komega_????
\end{verbatim}
%のようにモジュールを呼び出す. 
, where \verb|"????"|  is selected from the following words(methods) \verb|"CG_R"|, \verb|"CG_C"|, \verb|"COCG"|, \verb|"BiCG"|.
To utilize routines of MPI / Hybrid parallelization version,
the modules can be called by
\begin{verbatim}
  USE pkomega_???? .
\end{verbatim}

\subsection{Details of each routines}

\subsubsection{\texttt{????\_init}, \texttt{p????\_init}}

Set and initialize internal variables in libraries.
These routines should be called first before solving the shifted equation.
%ライブラリ内部変数の割り付けおよび初期化を行う.
%シフト線形方程式を解く前に, 一番初めに実行する.

\noindent Construction

\noindent Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_COCG_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold)
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_COCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
\begin{verbatim}
komega_CG_R_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
komega_CG_C_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
komega_COCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
komega_BiCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
pkomega_CG_C_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
pkomega_COCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
pkomega_BiCG_init(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm);
\end{verbatim}

\noindent Parameters

\begin{itemize}

\item \verb|ndim|

  \verb|INTEGER|. Scalar. Input. The dimension of solution vectors for the linearized equation.

\item \verb|nl|

  \verb|INTEGER|. Scalar. Input.  The dimension of projected solution vectors.

\item \verb|nz|

  \verb|INTEGER|. Scalar. Input. The number of shifted points.

\item \verb|x|

  \verb|DOUBLE PRECISION| (for \verb|CG_R_init|),
  \verb|DOUBLE COMPLEX| (otherwise).
  The array with the length of \verb|nl*nz|. Output.
  The solution vector. In this procedure,  \verb|0| vector is returned.
  
\item \verb|z|

  \verb|DOUBLE PRECISION| (for \verb|CG_R_init|, \verb|CG_C_init|),
  \verb|DOUBLE COMPLEX| (othewise).
The array with the length of \verb|nz|. Input. Shifted points.

\item \verb|itermax|

  \verb|INTEGER|. Scalar. Input. The maximum iteration number to restore the array for the restart calculation.
  The array is not restored when \verb|0| is input. In this case, variables for the restart calculation as described below cannot be output.

\item \verb|threshold|

  \verb|DOUBLE PRECISION|. Scalar. Input. The threshold value for the convergence determination.
  When the maximum absolute value for the residual vector of the seed equation becomes small compared to this value,
  the calculation is finished.

\item \verb|comm|

  \verb|INTEGER|. Scalar. Input. Only for MPI / Hybrid parallelization version.
  Communicators for MPI such as \verb|MPI_COMM_WORLD| are input.

\end{itemize}

\subsubsection{\texttt{????\_restart}, \texttt{p????\_restart}}

 For restart calculation, these modules are used instead of \verb|?_init|.
Set and initialize internal variables in libraries.
These routines should be called first before solving the shifted equation.
%ライブラリ内部変数の割り付けおよび初期化を行う.
 %シフト線形方程式を解く前に, 一番初めに実行する.

  \noindent Construction
  
  \noindent Fortran (Serial / OpenMP version)
  
\begin{verbatim}
CALL komega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &
&                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
&                 z_seed, r_l_save)
\end{verbatim}

  \noindent Fortran MPI / Hybrid parallelization version
  
\begin{verbatim}
CALL pkomega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
&                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &
&                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
&                 z_seed, r_l_save)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
  
\begin{verbatim}
komega_CG_R_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
 komega_CG_C_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
komega_COCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
komega_BiCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, status, &
&                 &iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
&                 &z_seed, r_l_save);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
  
\begin{verbatim}
pkomega_CG_R_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
pkomega_CG_C_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
pkomega_COCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
&                 &iter_old, v2, v12, alpha_save, beta_save, &z_seed, r_l_save);
pkomega_BiCG_restart(&ndim, &nl, &nz, x, z, &itermax, &threshold, &comm, status, &
&                 &iter_old, v2, v12, v4, v14, alpha_save, beta_save, &
&                 &z_seed, r_l_save);
\end{verbatim}


\noindent Parameters

\begin{itemize}

\item \verb|ndim, nl, nz, x, z, itermax, threshold, comm|

  The definition is same as \verb|?_init|. See the parameters in \verb|?_init|.
%  \verb|?_init|と同様.

\item \verb|status|

  \verb|INTEGER|. 
  The array with the length of \verb|3|.
  Output. The error code is returned.
  %長さ\verb|3|の配列. 出力. エラーコードを返す.
  \begin{description}
  \item [First component(\texttt{status(1)})]
   The current total number of iterations is returned.
   If the solution is converged or the calculation is abnormally terminated,
   the minus sign will be multiplied. In other cases, \verb|0| is returned.
   
    %現在の総反復回数が返される.
    %解が収束した場合, もしくは計算が破綻した場合には現在の総反復回数に
    %マイナスが付いた値が返される.
    %それ以外の場合には\verb|0|が返される.
    \verb|status(1)|が正の値の時のみ反復を続行できる.
    それ以外の場合は反復を進めても有意な結果は得られない.
    
  \item [Second component(\texttt{status(2)})]
    \verb|itermax|を有限にして, かつ\verb|itermax|回の反復で
    収束に達しなかった場合には\verb|1|が返される.
    $\alpha$が発散した場合には\verb|2|が返される.
    $\pi_{\rm seed}$が0にになった場合には\verb|3|が返される.
    \verb|COCG_restart|もしくは\verb|BiCG_restart|で,
    残差ベクトルと影の残差ベクトルが直交した場合には\verb|4|が返される.
    それ以外の場合には\verb|0|が返される.

  \item [Third component(\texttt{status(3)})]
    シード点のindexが返される.
  \end{description}

\item \verb|iter_old|

  \verb|INTEGER|. スカラー. 入力. 先行する計算での反復回数.

\item \verb|v2|

  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|ndim|の配列. 入力.
  先行する計算での最後の残差ベクトル.

\item \verb|v12|

  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|ndim|の配列. 入力.
  先行する計算での最後から2番目の残差ベクトル.

\item \verb|alpha_save|

  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|, \verb|CG_C_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|iter_old|の配列. 入力. 先行する計算での各反復での(Bi)CG法のParameters$\alpha$.

\item \verb|beta_save|

  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|, \verb|CG_C_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|iter_old|の配列. 入力. 先行する計算での各反復での(Bi)CG法のParameters$\beta$.

\item \verb|z_seed|

  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|, \verb|CG_C_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  スカラー. 入力. 先行する計算でのシードシフト.

\item \verb|r_l_save|
  
  \verb|DOUBLE PRECISION| (\verb|CG_R_restart|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|nl*iter_old|の配列. 入力.
  先行する計算での各反復での射影された残差ベクトル.

\item \verb|v4|

  \verb|BiCG_restart|の場合のみ使用.
  \verb|DOUBLE COMPLEX|.
  長さ\verb|ndim|の配列. 入力.
  先行する計算での最後の影の残差ベクトル.

\item \verb|v14|

  \verb|BiCG_restart|の場合のみ使用.
  \verb|DOUBLE COMPLEX|.
  長さ\verb|ndim|の配列. 入力.
  先行する計算での最後から2番目の影の残差ベクトル.

\end{itemize}

\subsubsection{\texttt{????\_update}, \texttt{p????\_update}}

ループ内で行列ベクトル積と交互に呼ばれて解を更新する.

\noindent Construction

\noindent Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_update(v12, v2, x, r_l, status)
CALL komega_CG_C_update(v12, v2, x, r_l, status)
CALL komega_COCG_update(v12, v2, x, r_l, status)
CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_update(v12, v2, x, r_l, status)
CALL pkomega_CG_C_update(v12, v2, x, r_l, status)
CALL pkomega_COCG_update(v12, v2, x, r_l, status)
CALL pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version

\begin{verbatim}
komega_CG_R_update(v12, v2, x, r_l, status);
komega_CG_C_update(v12, v2, x, r_l, status);
komega_COCG_update(v12, v2, x, r_l, status);
komega_BiCG_update(v12, v2, v14, v4, x, r_l, status);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_update(v12, v2, x, r_l, status);
pkomega_CG_C_update(v12, v2, x, r_l, status);
pkomega_COCG_update(v12, v2, x, r_l, status);
pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status);
\end{verbatim}

\noindent Parameters

\begin{itemize}

\item \verb|v12|

  \verb|DOUBLE PRECISION| (\verb|CG_R_update|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|ndim|の配列. 入出力.
  入力は残差ベクトル(\verb|v2|)と行列の積.
  出力は, 更新された残差ベクトルの各要素の絶対値のなかで最大のものが,
  先頭の要素に格納される(これは収束の具合を表示して調べる時などに用いる).

\item \verb|v2|

  \verb|DOUBLE PRECISION| (\verb|CG_R_update|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|ndim|の配列. 入出力.
  入力は残差ベクトル.
  出力は更新された残差ベクトル.

\item \verb|v14|
  
  \verb|BiCG_update|の場合のみ使用. \verb|DOUBLE COMPLEX|.
  長さ\verb|ndim|の配列. 入力.
  影の残差ベクトル(\verb|v4|)と行列の積.
  
\item \verb|v4|
  
  \verb|BiCG_update|の場合のみ使用. \verb|DOUBLE COMPLEX|.
  長さ\verb|ndim|の配列. 入出力.
  入力は影の残差ベクトル.
  出力は更新された影の残差ベクトル.

\item \verb|status|

  \verb|INTEGER|. 長さ\verb|3|の配列. 出力. エラーコードを返す.
  \begin{description}
  \item [第一成分(\texttt{status(1)})]
    現在の総反復回数が返される.
    解が収束した場合, もしくは計算が破綻した場合には現在の総反復回数に
    マイナスが付いた値が返される.
    それ以外の場合には\verb|0|が返される.
    \verb|status(1)|が正の値の時のみ反復を続行できる.
    それ以外の場合は反復を進めても有意な結果は得られない.
    
  \item [第二成分(\texttt{status(2)})]
    \verb|?_init|ルーチンで, \verb|itermax|を有限にして, かつ\verb|itermax|回の反復で
    収束に達しなかった場合には\verb|1|が返される.
    $\alpha$が発散した場合には\verb|2|が返される.
    $\pi_{\rm seed}$が0にになった場合には\verb|3|が返される.
    \verb|COCG_update|もしくは\verb|BiCG_update|で,
    残差ベクトルと影の残差ベクトルが直交した場合には\verb|4|が返される.
    それ以外の場合には\verb|0|が返される.

  \item [第三成分(\texttt{status(3)})]
    シード点のindexが返される.
  \end{description}

\end{itemize}

\subsubsection{\texttt{????\_getcoef}, \texttt{p????\_getcoef}}

後でリスタートを刷るときに必要な係数を取得する.
このルーチンを呼び出すためには,
\verb|?_init|ルーチンで\verb|itermax|を\verb|0|以外の値にしておく必要がある.

\noindent Construction

\noindent  Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
\begin{verbatim}
komega_CG_R_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
komega_CG_C_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
komega_COCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
komega_BiCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
pkomega_CG_C_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
pkomega_COCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
pkomega_BiCG_getcoef(alpha_save, beta_save, &z_seed, r_l_save);
\end{verbatim}

\noindent Parameters

\begin{itemize}
\item \verb|alpha_save|

  \verb|DOUBLE PRECISION| (\verb|CG_R_getoef|, \verb|CG_C_getoef|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  総反復回数と同じ長さの配列. 出力. 各反復での(Bi)CG法のParameters$\alpha$.

\item \verb|beta_save|

  \verb|DOUBLE PRECISION| (\verb|CG_R_getoef|, \verb|CG_C_getoef|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  総反復回数と同じ長さの配列. 出力. 各反復での(Bi)CG法のParameters$\beta$.

\item \verb|z_seed|

  \verb|DOUBLE PRECISION| (\verb|CG_R_getoef|, \verb|CG_C_getoef|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  スカラー. 出力. シードシフト.

\item \verb|r_l_save|
  
  \verb|DOUBLE PRECISION| (\verb|CG_R_getoef|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  \verb|nl|$\times$総反復回数の長さ配列. 出力.
  各反復での射影された残差ベクトル.
\end{itemize}

\subsubsection{\texttt{????\_getvec}, \texttt{p????\_getvec}}

後でリスタートをするときに必要な残差ベクトルを取得する.
このルーチンを呼び出すためには,
\verb|?_init|ルーチンで\verb|itermax|を\verb|0|以外の値にしておく必要がある.

\noindent Construction

\noindent Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_getvec(r_old)
CALL komega_CG_C_getvec(r_old)
CALL komega_COCG_getvec(r_old)
CALL komega_BiCG_getvec(r_old, r_tilde_old)
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_getvec(r_old)
CALL pkomega_CG_C_getvec(r_old)
CALL pkomega_COCG_getvec(r_old)
CALL pkomega_BiCG_getvec(r_old, r_tilde_old)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
\begin{verbatim}
komega_CG_R_getvec(r_old);
komega_CG_C_getvec(r_old);
komega_COCG_getvec(r_old);
komega_BiCG_getvec(r_old, r_tilde_old);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_getvec(r_old);
pkomega_CG_C_getvec(r_old);
pkomega_COCG_getvec(r_old);
pkomega_BiCG_getvec(r_old, r_tilde_old);
\end{verbatim}

\noindent Parameters

\begin{itemize}
  
\item \verb|r_old|

  \verb|DOUBLE PRECISION| (\verb|CG_R_getvec|の場合),
  \verb|DOUBLE COMPLEX| (それ以外).
  長さ\verb|ndim|の配列. 出力.
  先行する計算での最後から2番目の残差ベクトル.

\item \verb|r_tilde_old|

  \verb|BiCG_getvec|の場合のみ使用.
  \verb|DOUBLE COMPLEX|.
  長さ\verb|ndim|の配列. 出力.
  先行する計算での最後から2番目の影の残差ベクトル.

\end{itemize}

\subsubsection{\texttt{komega\_????\_getresidual}, \texttt{pkomega\_????\_getresidual}}

各シフト点での残差ベクトルの2-ノルムを取得する.
このルーチンは\verb|komega_????_init|と\verb|komega_????_finalize|の間の
任意の場所で呼び出すことが出来る.
また, いつ何回呼び出しても最終的な計算結果には影響を与えない.

\noindent Construction

\noindent Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_getresidual(res)
CALL komega_CG_C_getresidual(res)
CALL komega_COCG_getresidual(res)
CALL komega_BiCG_getresidual(res)
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_getresidual(res)
CALL pkomega_CG_C_getresidual(res)
CALL pkomega_COCG_getresidual(res)
CALL pkomega_BiCG_getresidual(res)
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
\begin{verbatim}
komega_CG_R_getresidual(res);
komega_CG_C_getresidual(res);
komega_COCG_getresidual(res);
komega_BiCG_getresidual(res);
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_getresidual(res);
pkomega_CG_C_getresidual(res);
pkomega_COCG_getresidual(res);
pkomega_BiCG_getresidual(res);
\end{verbatim}

\noindent Parameters

\begin{itemize}
  
\item \verb|res|

  \verb|DOUBLE PRECISION|.
  長さ\verb|nz|の配列. 出力.
  各シフト点での残差ベクトルの2-ノルム.

\end{itemize}

\subsubsection{\texttt{????\_finalize}, \texttt{p????\_finalize}}

ライブラリ内部で割りつけた配列のメモリを解放する.

\noindent Construction

\noindent Fortran Serial / OpenMP version
\begin{verbatim}
CALL komega_CG_R_finalize()
CALL komega_CG_C_finalize()
CALL komega_COCG_finalize()
CALL komega_BiCG_finalize()
\end{verbatim}

\noindent Fortran MPI / Hybrid parallelization version
\begin{verbatim}
CALL pkomega_CG_R_finalize()
CALL pkomega_CG_C_finalize()
CALL pkomega_COCG_finalize()
CALL pkomega_BiCG_finalize()
\end{verbatim}

\noindent C/C++ Serial / OpenMP version
\begin{verbatim}
komega_CG_R_finalize();
komega_CG_C_finalize();
komega_COCG_finalize();
komega_BiCG_finalize();
\end{verbatim}

\noindent C/C++ MPI / Hybrid parallelization version
\begin{verbatim}
pkomega_CG_R_finalize();
pkomega_CG_C_finalize();
pkomega_COCG_finalize();
pkomega_BiCG_finalize();
\end{verbatim}


\subsection{Sample codes for using shifted BiCG library}

As a typical example, the usage of shifted BiCG library is shown below.

\begin{lstlisting}
PROGRAM my_prog
  !
  USE komega_bicg, ONLY : komega_BiCG_init, komega_BiCG_restart, komega_BiCG_update, &
  &                       komega_BiCG_getcoef, komega_BiCG_getvec, komega_BiCG_finalize
  USE solve_cc_routines, ONLY : input_size, input_restart, &
  &                             projection, &
  &                             hamiltonian_prod, generate_system, &
  &                             output_restart, output_result
  !
  IMPLICIT NONE
  !
  INTEGER,SAVE :: &
  & rnd_seed, &
  & ndim,    & ! Size of Hilvert space
  & nz,      & ! Number of frequencies
  & nl,      & ! Number of Left vector
  & itermax, & ! Max. number of iteraction
  & iter_old   ! Number of iteraction of previous run
  !
  REAL(8),SAVE :: &
  & threshold ! Convergence Threshold
  !
  COMPLEX(8),SAVE :: &
  & z_seed ! Seed frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & z(:)         ! (nz): Frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & ham(:,:), &
  & rhs(:), &
  & v12(:), v2(:), & ! (ndim): Working vector
  & v14(:), v4(:), & ! (ndim): Working vector
  & r_l(:), & ! (nl) : Projeccted residual vector 
  & x(:,:) ! (nl,nz) : Projected result 
  !
  ! Variables for Restart
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & alpha(:), beta(:) ! (iter_old) 
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & r_l_save(:,:) ! (nl,iter_old) Projected residual vectors
  !
  ! Variables for Restart
  !
  INTEGER :: &
  & itermin, & ! First iteration in this run
  & iter,    & ! Counter for Iteration
  & status(3)
  !
  ! Input Size of vectors
  !
  CALL input_size(ndim,nl,nz)
  !
  ALLOCATE(v12(ndim), v2(ndim), v14(ndim), v4(ndim), r_l(nl), &
  &        x(nl,nz), z(nz), ham(ndim,ndim), rhs(ndim))
  !
  CALL generate_system(ndim, ham, rhs, z)
  !
  ! Check: Whether the restart file is exist.
  !
  CALL input_restart(iter_old, zseed, alpha, beta, r_l_save)
  !
  WRITE(*,*)
  WRITE(*,*) "#####  CG Initialization  #####"
  WRITE(*,*)
  !
  IF(iter_old > 0) THEN
    !
    ! When restarting, counter
    !
    itermin = iter_old + 1
    CALL komega_BiCG_restart(ndim, nl, nz, x, z, max(0,itermax), threshold, &
    &                 status, iter_old, v2, v12, v4, v14, alpha, &
    &                 beta, z_seed, r_l_save)
    !
    ! These vectors were saved in BiCG routine
    !
    DEALLOCATE(alpha, beta, r_l_save)
    !
    IF(status(1) /= 0) GOTO 10
    !
  ELSE
     !
     itermin = 1
     !
     ! Generate Right Hand Side Vector
     !
     v2(1:ndim) = rhs(1:ndim)
     v4(1:ndim) = CONJG(v2(1:ndim))
     !v4(1:ndim) = v2(1:ndim)
     !
     CALL komega_BiCG_init(ndim, nl, nz, x, z, max(0,itermax), threshold)
     !
  END IF
  !
  ! BiCG Loop
  !
  WRITE(*,*)
  WRITE(*,*) "#####  CG Iteration  #####"
  WRITE(*,*)
  !
  DO iter = 1, abs(itermax)
     !
     ! Projection of Residual vector into the space
     ! spaned by left vectors
     !
     r_l(1:nl) = projection(v2(1:nl))
     !
     ! Matrix-vector product
     !
     CALL hamiltonian_prod(Ham, v2, v12)
     CALL hamiltonian_prod(Ham, v4, v14)
     !
     ! Update result x with BiCG
     !
     CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
     !
     WRITE(*,'(a,i,a,3i,a,e15.5)') "lopp : ", iter, &
     &                             ", status : ", status(1:3), &
     &                             ", Res. : ", DBLE(v12(1))
     IF(status(1) < 0) EXIT
     !
  END DO
  !
  IF(status(2) == 0) THEN
     WRITE(*,*) "  Converged in iteration ", ABS(status(1))
  ELSE IF(status(2) == 1) THEN
     WRITE(*,*) "  Not Converged in iteration ", ABS(status(1))
  ELSE IF(status(2) == 2) THEN
     WRITE(*,*) "  Alpha becomes infinity", ABS(status(1))
  ELSE IF(status(2) == 3) THEN
     WRITE(*,*) "  Pi_seed becomes zero", ABS(status(1))
  ELSE IF(status(2) == 4) THEN
     WRITE(*,*) "  Residual & Shadow residual are orthogonal", ABS(status(1))
  END IF
  iter_old = ABS(status(1))
  !
  ! Get these vectors for restart in the Next run
  !
  IF(itermax > 0) THEN
     !
     ALLOCATE(alpha(iter_old), beta(iter_old), r_l_save(nl,iter_old))
     !
     CALL komega_BiCG_getcoef(alpha, beta, z_seed, r_l_save)
     CALL komega_BiCG_getvec(v12,v14)
     !
     CALL output_restart(iter_old, z_seed, alpha, beta, &
     &                   r_l_save, v12, v14)
     !
     DEALLOCATE(alpha, beta, r_l_save)
     !     
  END IF
  !
10 CONTINUE
  !
  ! Deallocate all intrinsic vectors
  !
  CALL komega_BiCG_finalize()
  !
  ! Output to a file
  !
  CALL output_result(nl, nz, z, x, r_l)
  !
  DEALLOCATE(v12, v2, v14, v4, r_l, x, z)
  !
  WRITE(*,*)
  WRITE(*,*) "#####  Done  #####"
  WRITE(*,*)
  !
END PROGRAM my_prog
\end{lstlisting}

\section{Contact}

If you have any comments, questions, bug reports etc. about this library,
please contact to the main developer (Mitsuaki Kawamura) by sending the e-mail (the address is shown below),
\begin{verbatim}
mkawamura_at_issp.u-tokyo.ac.jp .
\end{verbatim}
Please change \verb|_at_| as \verb|@|, when you will send the e-mail.

\begin{thebibliography}{99}
\bibitem{BiCG}
  A. Frommer, Computing {\bf 70}, 87 (2003).
  
\bibitem{COCG}
  S. Yamamoto, T. Sogabe, T. Hoshi, S.-L. Zhang, and T. Fujiwara, J. Phys. Soc. Jpn. {\bf 77}, 114713 (2008).
\end{thebibliography}

\end{document}
