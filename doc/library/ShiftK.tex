\documentclass[12pt,titlepage]{jarticle}
%\documentclass[12pt,titlepage]{article}
%\usepackage[whole]{bxcjkjatype}
%\setminchofont{ipaexm.ttf}
%\setgothicfont{ipaexg.ttf}
%\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{bm}% bold math
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage {framed,color}
%
%\pagestyle{fancy}
%
\topmargin=-30mm
\textheight=27cm
\textwidth=17cm
\oddsidemargin=-0.04 cm
\evensidemargin=-1.04cm
%1inchi = 2.54cm
%A4 = 21.0 * 29.7
%
\makeatletter
\renewenvironment{leftbar}{%
%  \def\FrameCommand{\vrule width 3pt \hspace{10pt}}%  デフォルトの線の太さは3pt
  \def\FrameCommand{\vrule width 1pt \hspace{0pt}}% 
  \MakeFramed {\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\makeatother

\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{lmodern}
\usepackage{listings}
\lstset{language=[90]Fortran,
  basicstyle=\ttfamily\small,
  keywordstyle=\color[rgb]{0,0,0.7},
  commentstyle=\color[rgb]{0.5,0,0},
  morecomment=[l]{!\ }% Comment only with space after !
}



\begin{document}
%
% Cover
%
\title{Shifted Krylov法ライブラリ マニュアル}
\author{東京大学物性研究所 ソフトウェア高度化推進チーム}
\date{\today}
\maketitle
%

%
% Contents
%
\tableofcontents

\section{概要}

本資料はKrylov部分空間法に基づくシフト線形方程式群ソルバーに関するマニュアルである.
本ライブラリは, (射影付き)シフト線形問題
\begin{align}
  G_{i j}(z) = \langle i | (z-{\hat H})^{-1}| j \rangle \equiv 
  {\boldsymbol \varphi}_i^{*} \cdot (z-{\hat H})^{-1} {\boldsymbol \varphi}_j
\end{align}
を, Krylov部分空間法を用いて解くためのルーチンを提供する.
言語はfortranを用いる. 
また, BLASレベル1ルーチンを使用する.

\section{アルゴリズム}

このライブラリは, ${\hat H}$および$z$が複素数のであるか実数であるかに応じて,
次の4種類の計算をサポートする(${\hat H}$は複素数の場合はエルミート行列、実数の場合は実対称行列).

\begin{itemize}
\item ${\hat H}$も$z$も両方複素数の場合 : Shifted Bi-Conjugate Gradient(BiCG)法 \cite{BiCG} or Shifted Conjugate Orthogonal Conjugate Gradient(COCG)法 \cite{COCG}
\item ${\hat H}$が実数で$z$が複素数の場合 : Shifted Conjugate Orthogonal Conjugate Gradient(COCG)法 \cite{COCG}
\item ${\hat H}$が複素数で$z$が実数の場合 : Shifted Conjugate Gradient(CG)法 (複素ベクトル)
\item ${\hat H}$も$z$も両方実数の場合 : Shifted Conjugate Gradient(CG)法 (実ベクトル)
\end{itemize}
いずれの場合も Seed switching を行う.

左ベクトルを$N_L$個, 右ベクトルを$N_R$個(典型的には1個),

%\newpage
\subsection{Seed switch 付き Shifted BiCG法}

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, ${\tilde {\boldsymbol r}} = $任意,
${\boldsymbol r}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\tilde {\boldsymbol r}}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\tilde {\boldsymbol r}}^*\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed}^* {\hat I} - {\hat H}) {\tilde {\boldsymbol r}},\;
{\boldsymbol q} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\tilde {\boldsymbol r}}
- \alpha^* {\boldsymbol q} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\tilde {\boldsymbol r}}^{\rm old},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}},\; {\tilde {\boldsymbol r}} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old},\; 
{\tilde {\boldsymbol r}} = {\tilde {\boldsymbol r}} / \pi_{\rm seed}^{ *},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} / \pi_{\rm seed}^{{\rm old}*}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Seed switch 付き Shifted COCG法}

BiCGのアルゴリズムで, ${\tilde {\boldsymbol r}} = {\boldsymbol r}^*,\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{{\rm old}*}$とすると得られる.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r} \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Seed switch 付き Shifted CG法}

BiCGのアルゴリズムで, ${\tilde {\boldsymbol r}} = {\boldsymbol r},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{\rm old}$とすると得られる.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}^* \cdot {\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\left(\frac{\pi^{\rm old}_k}{\pi_k } \right)^2 \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / {\pi_{\rm seed}^{\rm old}}^2$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old}/\pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

\section{プログラム内でのライブラリの使用方法}

以下では$N_R$のループは省略する(各右辺ベクトルごとに同じ事をすればいいので).
また$G_{i j}(z_k)$の代わりに$N_z$個の$N_L$次元の解ベクトル${\bf x}_{k}$を求める.

ユーザーの用意
\begin{itemize}
\item ベクトル(ヒルベルト空間)のサイズ$N_H$, $N_z$個の$z$
\item サイズ$N_H$のベクトルを2本(BiCGの時には4本)Allocateしておく.
\item ハミルトニアン-ベクトル積を行う部分
\item 解ベクトルをAllocateしておく. ただし, これは必ずしも$N_H \times N_z$である必要はない.
  実際前節の場合は$N_L \times N_z$である.この時(双)共役勾配ベクトル${{\bf p}_k}$も
  $N_z$個の$N_L$次元のベクトルである.
  $N_H$次元の残差ベクトルを$N_L$次元へ変換するところはユーザーが行う.
  \begin{align}
    {\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
    {\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
  \end{align}
\item 各iterationでの$\alpha, \beta, {\bf r}^{\rm L}$を保存しておき, 
あとで利用する場合には最大反復回数\verb|itermax|を設定する.
\end{itemize}
ライブラリの各ルーチンの名前は仮に次のようにしておく

\begin{itemize}
\item \verb|BiCG_init|, \verb|COCG_init|, \verb|CG_init|

ライブラリ内部で使う(ユーザーの目に触れない)変数のAllocateや初期値設定を行う.

\item \verb|BiCG_update|, \verb|COCG_update|, \verb|CG_update|

Iteration の中で呼び出される. 解ベクトル群の更新等を行う.

%%\item \verb|BiCG_update1|, \verb|BiCG_update2|
%%
%%BiCGで, ベクトルの本数を1本減らしてメモリを節約したいときに\verb|BiCG_update|の代わりに用いる.
%%この場合には\verb|BiCG_init|の代わりに\verb|BiCG_init0|を使う.

\item \verb|BiCG_finalize|, \verb|COCG_finalize|, \verb|CG_finalize|

Allocateしたライブラリ内部ベクトルを開放する.

\item \verb|BiCG_getcoef|, \verb|COCG_getcoef|, \verb|CG_getcoef|

各iterationで保存しておいた$\alpha$, $\beta$, $z_{\rm seed}$, ${\bf r}^{\rm L}$を取り出す.

\item \verb|BiCG_getvec|, \verb|COCG_getvec|, \verb|CG_getvec|

${\boldsymbol r}$, ${\boldsymbol r}^{\rm old}$, 
${\tilde {\boldsymbol r}}$, ${\tilde {\boldsymbol r}}^{\rm old}$
を取り出す.

\item \verb|BiCG_restart|, \verb|COCG_restart|, \verb|CG_restart|

保存しておいた$\alpha$等を用いて, 新規の$z$での計算を行う.
${\boldsymbol r}$等も有る場合には
\verb|BiCG_init|, \verb|COCG_init|, \verb|CG_init|
の代わりに用いてリスタートすることもできる.

\end{itemize}

\subsection{Shifted BiCGライブラリの動作イメージ}%%(メモリ節約なし)}

\noindent
Allocate ${\boldsymbol v}_{1 2}$, ${\boldsymbol v}_{1 3}$, 
${\boldsymbol v}_2$, ${\boldsymbol v}_3$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|BiCG_init(N_H, N_L, N_z, v_2, v_4, x, z, itermax)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_3$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_4 = {\boldsymbol v}_2^*$(任意),
  ${\boldsymbol v}_3 = {\boldsymbol v}_5 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$,
  ${\boldsymbol v}_4 \equiv {\tilde {\boldsymbol r}}$, 
  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
  \\
  \verb|BiCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2$, 
${\boldsymbol v}_{1 4} = {\hat H} {\boldsymbol v}_4$  
$ [ ({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4}) = {\hat H}
  ({\boldsymbol v}_2, {\boldsymbol v}_4)とも書ける]$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|BiCG_update(v_12, v_14, v_2, v_4, x, r_small)| start
  \\\hspace{1.0cm}
  $\circ$シード方程式
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_4^* \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}$, 
  ${\boldsymbol v}_{1 4} = z_{\rm seed}^* {\boldsymbol v}_4 - {\boldsymbol v}_{1 4}$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$シフト方程式
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$, 
  ${\boldsymbol v}_3 = {\boldsymbol v}_2,\;
  {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 4} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\boldsymbol v}_4
  - \alpha^* {\boldsymbol v}_{1 4} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5$, 
  ${\boldsymbol v}_5 = {\boldsymbol v}_4,\; 
  {\boldsymbol v}_4 = {\boldsymbol v}_{1 4}$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  $|\pi_k|$が最も小さい$k$を探す. 
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$,
  ${\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{*}$, 
  ${\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
\verb|BiCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
\noindent
\verb|BiCG_finalize| start
\\ \hspace{0.5cm}
Deallocate ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
\\
\verb|BiCG_finalize| finish
\end{leftbar}

\subsection{Shifted COCGライブラリの動作イメージ}

\noindent
Allocate ${\boldsymbol v}_1$, ${\boldsymbol v}_2$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
\\ 
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_init(N_H, N_L, N_z, x, z)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_3 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$. )
  \\
  \verb|COCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|COCG_update(v_1, v_2, x, p, r_small)| start
  \\\hspace{1.0cm}
  $\circ$シード方程式
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$シフト方程式
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_3 = {\boldsymbol v}_2$,
  ${\boldsymbol v}_2 = {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  $|\pi_k|$が最も小さい$k$を探す. 
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
  \verb|COCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_finalize| start
  \\ \hspace{0.5cm}
  Deallocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\
  \verb|COCG_finalize| finish
\end{leftbar}
\vspace{-1em}

\subsection{Shifted CGライブラリの動作イメージ}

COCGと同様.

\section{使用方法}

各ライブラリともユーザーはライブラリ名および型を指定し、
\begin{itemize}
\item 初期設定 (init関数)
\item アップデート (update関数)
\item 計算情報出力 (getcoef, getvec関数などを呼び出力)
\item 終了関数 (finalize関数)
\end{itemize}
の手順で関数を使用することで、計算が実施される。
なお、リスタートを行う場合には
\begin{itemize}
\item 初期設定関数(init関数, restart関数)
\item アップデート (update関数)
\item 計算情報出力 (getcoef, getvec関数などを呼び出力)
\item 終了関数 (finalize関数)
\end{itemize}
の手順で実行する。
 
以下、代表的な例としてShifted BiCGライブラリの場合の使用方法を記載する。

\subsection{Shifted BiCGライブラリの使用方法}

\begin{lstlisting}
PROGRAM my_prog
  !
  USE shifted_bicg, ONLY : BiCG_init, BiCG_restart, BiCG_update, &
  &                        BiCG_getcoef, BiCG_getvec, BiCG_finalize
  USE solve_cc_routines, ONLY : input_size, input_restart, &
  &                             projection, &
  &                             hamiltonian_prod, generate_system, &
  &                             output_restart, output_result
  !
  IMPLICIT NONE
  !
  INTEGER,SAVE :: &
  & rnd_seed, &
  & ndim,    & ! Size of Hilvert space
  & nz,      & ! Number of frequencies
  & nl,      & ! Number of Left vector
  & itermax, & ! Max. number of iteraction
  & iter_old   ! Number of iteraction of previous run
  !
  REAL(8),SAVE :: &
  & threshold ! Convergence Threshold
  !
  COMPLEX(8),SAVE :: &
  & z_seed ! Seed frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & z(:)         ! (nz): Frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & ham(:,:), &
  & rhs(:), &
  & v12(:), v2(:), & ! (ndim): Working vector
  & v14(:), v4(:), & ! (ndim): Working vector
  & r_l(:), & ! (nl) : Projeccted residual vector 
  & x(:,:) ! (nl,nz) : Projected result 
  !
  ! Variables for Restart
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & alpha(:), beta(:) ! (iter_old) 
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &
  & r_l_save(:,:) ! (nl,iter_old) Projected residual vectors
  !
  ! Variables for Restart
  !
  INTEGER :: &
  & itermin, & ! First iteration in this run
  & iter,    & ! Counter for Iteration
  & status(3)
  !
  ! Input Size of vectors
  !
  CALL input_size(ndim,nl,nz)
  !
  ALLOCATE(v12(ndim), v2(ndim), v14(ndim), v4(ndim), r_l(nl), x(nl,nz), z(nz), ham(ndim,ndim), rhs(ndim))
  !
  CALL generate_system(ndim, ham, rhs, z)
  !
  ! Check: Whether the restart file is exist.
  !
  CALL input_restart(iter_old, zseed, alpha, beta, r_l_save)
  !
  WRITE(*,*)
  WRITE(*,*) "#####  CG Initialization  #####"
  WRITE(*,*)
  !
  IF(iter_old > 0) THEN
    !
    ! When restarting, counter
    !
    itermin = iter_old + 1
    CALL BiCG_restart(ndim, nl, nz, x, z, max(0,itermax), threshold, status, &
    &                 iter_old, v2, v12, v4, v14, alpha, beta, z_seed, r_l_save)
    !
    ! These vectors were saved in BiCG routine
    !
    DEALLOCATE(alpha, beta, r_l_save)
    !
    IF(status(1) /= 0) GOTO 10
    !
  ELSE
     !
     itermin = 1
     !
     ! Generate Right Hand Side Vector
     !
     v2(1:ndim) = rhs(1:ndim)
     v4(1:ndim) = CONJG(v2(1:ndim))
     !v4(1:ndim) = v2(1:ndim)
     !
     CALL BiCG_init(ndim, nl, nz, x, z, max(0,itermax), threshold, status)
     !
  END IF
  !
  ! BiCG Loop
  !
  WRITE(*,*)
  WRITE(*,*) "#####  CG Iteration  #####"
  WRITE(*,*)
  !
  DO iter = 1, abs(itermax)
     !
     ! Projection of Residual vector into the space
     ! spaned by left vectors
     !
     r_l(1:nl) = projection(v2(1:nl))
     !
     ! Matrix-vector product
     !
     CALL hamiltonian_prod(Ham, v2, v12)
     CALL hamiltonian_prod(Ham, v4, v14)
     !
     ! Update result x with BiCG
     !
     CALL BiCG_update(v12, v2, v14, v4, x, r_l, status)
     !
     WRITE(*,'(a,i,a,3i,a,e15.5)') "lopp : ", iter, &
     &                             ", status : ", status(1:3), &
     &                             ", Res. : ", DBLE(v12(1))
     IF(status(1) /= 0) EXIT
     !
  END DO
  !
  IF(status(1) > 0) THEN
     WRITE(*,*) "  Converged in iteration ", status(1)
  ELSE
     WRITE(*,*) "  Not Converged in iteration ", -status(1)
  END IF
  iter_old = abs(status(1))
  !
  ! Get these vectors for restart in the Next run
  !
  IF(itermax > 0) THEN
     !
     ALLOCATE(alpha(iter_old), beta(iter_old), r_l_save(nl,iter_old))
     !
     CALL BiCG_getcoef(alpha, beta, z_seed, r_l_save)
     CALL BiCG_getvec(v12,v14)
     !
     CALL output_restart(iter_old, z_seed, alpha, beta, r_l_save, v12, v14)
     !
     DEALLOCATE(alpha, beta, r_l_save)
     !     
  END IF
  !
10 CONTINUE
  !
  ! Deallocate all intrinsic vectors
  !
  CALL BiCG_finalize()
  !
  ! Output to a file
  !
  CALL output_result(nl, nz, z, x, r_l)
  !
  DEALLOCATE(v12, v2, v14, v4, r_l, x, z)
  !
  WRITE(*,*)
  WRITE(*,*) "#####  Done  #####"
  WRITE(*,*)
  !
END PROGRAM my_prog
\end{lstlisting}


\begin{thebibliography}{99}
\bibitem{BiCG}
  A. Frommer, Computing {\bf 70}, 87 (2003).
  
\bibitem{COCG}
  S. Yamamoto, T. Sogabe, T. Hoshi, S.-L. Zhang, and T. Fujiwara, J. Phys. Soc. Jpn. {\bf 77}, 114713 (2008).
\end{thebibliography}

\end{document}
