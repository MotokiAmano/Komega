\documentclass[12pt,titlepage]{jarticle}
%\documentclass[12pt,titlepage]{article}
%\usepackage[whole]{bxcjkjatype}
%\setminchofont{ipaexm.ttf}
%\setgothicfont{ipaexg.ttf}
%\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{bm}% bold math
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage {framed,color}
%
%\pagestyle{fancy}
%
\topmargin=-30mm
\textheight=27cm
\textwidth=17cm
\oddsidemargin=-0.04 cm
\evensidemargin=-1.04cm
%1inchi = 2.54cm
%A4 = 21.0 * 29.7
%
\makeatletter
\renewenvironment{leftbar}{%
%  \def\FrameCommand{\vrule width 3pt \hspace{10pt}}%  デフォルトの線の太さは3pt
  \def\FrameCommand{\vrule width 1pt \hspace{0pt}}% 
  \MakeFramed {\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\makeatother

\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{lmodern}
\usepackage{listings}
\lstset{language=[90]Fortran,
  basicstyle=\ttfamily\small,
  keywordstyle=\color[rgb]{0,0,0.7},
  commentstyle=\color[rgb]{0.5,0,0},
  morecomment=[l]{!\ }% Comment only with space after !
}



\begin{document}
%
% Cover
%
\title{Shifted Krylov法ライブラリ設計書 ver.0.5}
\author{東京大学物性研究所 ソフトウェア高度化推進チーム}
\date{\today}
\maketitle
%

%
% Contents
%
\tableofcontents

\section{概要}

本資料はKrylov部分空間法に基づくシフト線形方程式群ソルバーに関する設計書である.
本ライブラリは, HPhiにおけるGreen関数計算
\begin{align}
  G_{i j}(z) = \langle i | (z-{\hat H})^{-1}| j \rangle \equiv 
  {\boldsymbol \varphi}_i^{*} \cdot (z-{\hat H})^{-1} {\boldsymbol \varphi}_j
\end{align}
に用いられる事を想定して作られる.
ただし, なるべく汎用性も持たせられるようにもする.
言語はfortranを用いる. 
また, BLASレベル1ルーチンを使用する.

\section{アルゴリズム}

このライブラリは, ${\hat H}$および$z$が複素数のであるか実数であるかに応じて,
次の4種類の計算をサポートする(${\hat H}$は複素数の場合はエルミート行列、実数の場合は実対称行列).

\begin{itemize}
\item ${\hat H}$も$z$も両方複素数の場合 : Shifted Bi-Conjugate Gradient(BiCG)法 \cite{BiCG} or Shifted Conjugate Orthogonal Conjugate Gradient(COCG)法 \cite{COCG}
\item ${\hat H}$が実数で$z$が複素数の場合 : Shifted Conjugate Orthogonal Conjugate Gradient(COCG)法 \cite{COCG}
\item ${\hat H}$が複素数で$z$が実数の場合 : Shifted Conjugate Gradient(CG)法 (複素ベクトル)
\item ${\hat H}$も$z$も両方実数の場合 : Shifted Conjugate Gradient(CG)法 (実ベクトル)
\end{itemize}
いずれの場合も Seed switching を行う.

HPhiの計算では左ベクトルを$N_L$個, 右ベクトルを$N_R$個(典型的には1個),

$z$を$N_z$個としてGreen関数計算を行うものとする.
実装にあたっての優先順位は山元氏から提供されたコードをもとにCG法、COCG法の順に行う。具体的には\\
(${\hat H}$,$z$)=(実数, 実数)$\to$(複素数, 実数)$\to$(実数, 複素数)$\to$ (複素数, 複素数)\\
の順に対応し、各アルゴリズムに対しては独立した最小単位のライブラリとしても使用できるように考慮する。

%\newpage
\subsection{Seed switch 付き Shifted BiCG法}

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, ${\tilde {\boldsymbol r}} = $任意,
${\boldsymbol r}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\tilde {\boldsymbol r}}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\tilde {\boldsymbol r}}^*\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed}^* {\hat I} - {\hat H}) {\tilde {\boldsymbol r}},\;
{\boldsymbol q} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\tilde {\boldsymbol r}}
- \alpha^* {\boldsymbol q} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\tilde {\boldsymbol r}}^{\rm old},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}},\; {\tilde {\boldsymbol r}} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old},\; 
{\tilde {\boldsymbol r}} = {\tilde {\boldsymbol r}} / \pi_{\rm seed}^{ *},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} / \pi_{\rm seed}^{{\rm old}*}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / |\pi_{\rm seed}^{\rm old}|^2$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Seed switch 付き Shifted COCG法}

BiCGのアルゴリズムで, ${\tilde {\boldsymbol r}} = {\boldsymbol r}^*,\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{{\rm old}*}$とすると得られる.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r} \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}\cdot{\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / |\pi_{\rm seed}^{\rm old}|^2$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

%\newpage
\subsection{Seed switch 付き Shifted CG法}

BiCGのアルゴリズムで, ${\tilde {\boldsymbol r}} = {\boldsymbol r},\; 
{\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{\rm old}$とすると得られる.

\noindent
$G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)$
\\
do $j = 1 \cdots N_R$
\\\hspace{0.5cm}
${\boldsymbol r} = {\boldsymbol \varphi_j}$, 
${\boldsymbol r}^{\rm old} = {\bf 0}$
\\\hspace{0.5cm}
$p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
\\\hspace{0.5cm}
$\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
\\\hspace{0.5cm}
do iteration
\\\hspace{1.0cm}
$\circ$シード方程式
\\\hspace{1.0cm}
$\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r}^* \cdot {\boldsymbol r}$
\\\hspace{1.0cm}
$\beta = \rho / \rho^{\rm old}$
\\\hspace{1.0cm}
${\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}$
\\\hspace{1.0cm}
$\alpha^{\rm old} = \alpha,\; 
\alpha = \frac{\rho}{{\boldsymbol r}^* \cdot {\boldsymbol q} - \beta \rho / \alpha }$
\\\hspace{1.0cm}
$\circ$シフト方程式
\\\hspace{1.0cm}
do $k = 1 \cdots N_z$
\\\hspace{1.5cm}
$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
\\\hspace{1.5cm}
do $i = 1 \cdots N_L$
\\\hspace{2.0cm}
$p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + 
\left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta p_{i k}$
\\\hspace{2.0cm}
$G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}$
\\\hspace{2.0cm}
$\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
\\\hspace{1.5cm}
end do $i$
\\\hspace{1.0cm}
end do $k$
\\\hspace{1.0cm}
${\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r}
- \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}$
\\\hspace{1.0cm}
$\circ$ Seed switch
\\\hspace{1.0cm}
$|\pi_k|$が最も小さい$k$を探す. 
$\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
\\\hspace{1.0cm}
${\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; 
{\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}$
\\\hspace{1.0cm}
$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
$\rho = \rho / |\pi_{\rm seed}^{\rm old}|^2$
\\\hspace{1.0cm}
$\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old}/\pi_{\rm seed}^{\rm old}\}$
\\\hspace{1.0cm}
if($|{\boldsymbol r}| < $Threshold) exit
\\\hspace{0.5cm}
end do iteration
\\
end do $j$

\section{ライブラリの設計}

以下では$N_R$のループは省略する(各右辺ベクトルごとに同じ事をすればいいので).
また$G_{i j}(z_k)$の代わりに$N_z$個の$N_L$次元の解ベクトル${\bf x}_{k}$を求める.

ユーザーの用意
\begin{itemize}
\item ベクトル(ヒルベルト空間)のサイズ$N_H$, $N_z$個の$z$
\item サイズ$N_H$のベクトルを2本(BiCGの時には4本)Allocateしておく.
\item ハミルトニアン-ベクトル積を行う部分
\item 解ベクトルをAllocateしておく. ただし, これは必ずしも$N_H \times N_z$である必要はない.
  実際前節の場合は$N_L \times N_z$である.この時(双)共役勾配ベクトル${{\bf p}_k}$も
  $N_z$個の$N_L$次元のベクトルである.
  $N_H$次元の残差ベクトルを$N_L$次元へ変換するところはユーザーが行う.
  \begin{align}
    {\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
    {\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
  \end{align}
\item 各iterationでの$\alpha, \beta, {\bf r}^{\rm L}$を保存しておき, 
あとで利用する場合には最大反復回数\verb|itermax|を設定する.
\end{itemize}
ライブラリの各ルーチンの名前は仮に次のようにしておく

\begin{itemize}
\item \verb|BiCG_init|, \verb|COCG_init|, \verb|CG_init|

ライブラリ内部で使う(ユーザーの目に触れない)変数のAllocateや初期値設定を行う.

\item \verb|BiCG_update|, \verb|COCG_update|, \verb|CG_update|

Iteration の中で呼び出される. 解ベクトル群の更新等を行う.

%%\item \verb|BiCG_update1|, \verb|BiCG_update2|
%%
%%BiCGで, ベクトルの本数を1本減らしてメモリを節約したいときに\verb|BiCG_update|の代わりに用いる.
%%この場合には\verb|BiCG_init|の代わりに\verb|BiCG_init0|を使う.

\item \verb|BiCG_finalize|, \verb|COCG_finalize|, \verb|CG_finalize|

Allocateしたライブラリ内部ベクトルを開放する.

\item \verb|BiCG_getcoef|, \verb|COCG_getcoef|, \verb|CG_getcoef|

各iterationで保存しておいた$\alpha$, $\beta$, $z_{\rm seed}$, ${\bf r}^{\rm L}$を取り出す.

\item \verb|BiCG_getvec|, \verb|COCG_getvec|, \verb|CG_getvec|

${\boldsymbol r}$, ${\boldsymbol r}^{\rm old}$, 
${\tilde {\boldsymbol r}}$, ${\tilde {\boldsymbol r}}^{\rm old}$
を取り出す.

\item \verb|BiCG_restart|, \verb|COCG_restart|, \verb|CG_restart|

保存しておいた$\alpha$等を用いて, 新規の$z$での計算を行う.
${\boldsymbol r}$等も有る場合には
\verb|BiCG_init|, \verb|COCG_init|, \verb|CG_init|
の代わりに用いてリスタートすることもできる.

\end{itemize}

\subsection{Shifted BiCGライブラリの動作イメージ}%%(メモリ節約なし)}

\noindent
Allocate ${\boldsymbol v}_{1 2}$, ${\boldsymbol v}_{1 3}$, 
${\boldsymbol v}_2$, ${\boldsymbol v}_3$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|BiCG_init(N_H, N_L, N_z, v_2, v_3, x, z, itermax)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_3 = {\boldsymbol v}_2$(任意),
  ${\boldsymbol v}_4 = {\boldsymbol v}_5 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\tilde {\boldsymbol r}}$, 
  ${\boldsymbol v}_4 \equiv {\boldsymbol r}^{\rm old}$,
  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
  \\
  \verb|BiCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2$, 
  ${\boldsymbol v}_{1 3} = {\hat H} {\boldsymbol v}_3$  
$[ ({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 3}) = {\hat H}
  ({\boldsymbol v}_2, {\boldsymbol v}_3)とも書ける]$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|BiCG_update(v_12, v_13, v_2, v_3, x, r_small)| start
  \\\hspace{1.0cm}
  $\circ$シード方程式
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_3^* \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}$, 
  ${\boldsymbol v}_{1 3} = z_{\rm seed}^* {\boldsymbol v}_3 - {\boldsymbol v}_{1 3}$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$シフト方程式
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k$, $\pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_4$, 
  ${\boldsymbol v}_4 = {\boldsymbol v}_2,\;
  {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_{1 3} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\boldsymbol v}_3
  - \alpha^* {\boldsymbol v}_{1 3} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5$, 
  ${\boldsymbol v}_5 = {\boldsymbol v}_3,\; 
  {\boldsymbol v}_3 = {\boldsymbol v}_{1 3}$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  $|\pi_k|$が最も小さい$k$を探す. 
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{*}$, 
  ${\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{\rm old}$,
  ${\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / |\pi_{\rm seed}^{\rm old}|^2$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
\verb|BiCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
\noindent
\verb|BiCG_finalize| start
\\ \hspace{0.5cm}
Deallocate ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
\\
\verb|BiCG_finalize| finish
\end{leftbar}

%%\subsection{Shifted BiCGライブラリの動作イメージ(メモリ節約版)}
%%
%%\noindent
%%Allocate ${\boldsymbol v}_1$, ${\boldsymbol v}_2$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
%%\\ 
%%${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
%%\begin{leftbar}
%%  \verb|BiCG_init0(N_H, N_L, N_z, v_2, x, z, itermax)| start
%%  \\ \hspace{0.5cm}
%%  Allocate ${\boldsymbol v}_3$, ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, 
%%  $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
%%  \\ \hspace{0.5cm}
%%  Copy $\{z_k\}$
%%  \\ \hspace{0.5cm}
%%  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
%%  \\ \hspace{0.5cm}
%%  ${\boldsymbol v}_3 = {\boldsymbol v}_2$(任意),
%%  ${\boldsymbol v}_4 = {\boldsymbol v}_5 = {\bf 0}$,
%%  \\ \hspace{0.5cm}
%%  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
%%  \\ \hspace{0.5cm}
%%  $\rho = 1,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0$ 
%%  \\ \hspace{0.5cm}
%%  (この時点で, 
%%  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
%%  ${\boldsymbol v}_3 \equiv {\tilde {\boldsymbol r}}$, 
%%  ${\boldsymbol v}_4 \equiv {\boldsymbol r}^{\rm old}$,
%%  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
%%  \\
%%  \verb|BiCG_init| finish
%%\end{leftbar}
%%do iteration
%%\\\hspace{0.5cm}
%%${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
%%\\\hspace{0.5cm}
%%${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$
%%\begin{leftbar}
%%  \hspace{0.5cm}
%%  \verb|BiCG_update1(v_1, v_2, x, r_small)| start
%%  \\\hspace{1.0cm}
%%  $\circ$シード方程式
%%  \\\hspace{1.0cm}
%%  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_3^* \cdot {\boldsymbol v}_2$
%%  \\\hspace{1.0cm}
%%  $\beta = \rho / \rho^{\rm old}$
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1$
%%  \\\hspace{1.0cm}
%%  $\alpha^{\rm old} = \alpha,\; 
%%  \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }$
%%  \\\hspace{1.0cm}
%%  $\circ$シフト方程式
%%  \\\hspace{1.0cm}
%%  do $k = 1 \cdots N_z$
%%  \\\hspace{1.5cm}
%%  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
%%  \\\hspace{1.5cm}
%%  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
%%  \left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta {\bf p}_{k}$
%%  \\\hspace{1.5cm}
%%  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
%%  \\\hspace{1.5cm}
%%  $\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}$
%%  \\\hspace{1.0cm}
%%  end do $k$
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
%%  - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_4$
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_4 = {\boldsymbol v}_2$,
%%  ${\boldsymbol v}_2 = {\boldsymbol v}_3$,
%%  ${\boldsymbol v}_3 = {\boldsymbol v}_1$
%%  \\\hspace{1.0cm}
%%  (この時点で, 
%%  ${\boldsymbol v}_2 \equiv {\tilde {\boldsymbol r}}$, 
%%  ${\boldsymbol v}_3 \equiv {\boldsymbol r}$, 
%%  ${\boldsymbol v}_4 \equiv {\boldsymbol r}^{\rm old}$,
%%  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
%%  \\\hspace{0.5cm}
%%  \verb|BiCG_update1| finish
%%\end{leftbar}
%%\hspace{0.5cm}
%%${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$
%%\begin{leftbar}
%%  \hspace{0.5cm}
%%  \verb|BiCG_update2(v_1, v_2)| start
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_1 = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\boldsymbol v}_2
%%  - \alpha^* (z_{\rm seed}^* {\boldsymbol v}_2 - {\boldsymbol v}_1) 
%%  - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5$
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_5 = {\boldsymbol v}_2$,
%%  ${\boldsymbol v}_2 = {\boldsymbol v}_3$,
%%  ${\boldsymbol v}_3 = {\boldsymbol v}_1$
%%  \\\hspace{1.0cm}
%%  (この時点で, 
%%  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
%%  ${\boldsymbol v}_3 \equiv {\tilde {\boldsymbol r}}$, 
%%  ${\boldsymbol v}_4 \equiv {\boldsymbol r}^{\rm old}$,
%%  ${\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )
%%  \\\hspace{1.0cm}
%%  $\circ$ Seed switch
%%  \\\hspace{1.0cm}
%%  $|\pi_k|$が最も小さい$k$を探す. $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
%%  \\\hspace{1.0cm}
%%  $\pi_k = \pi_k /\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old} (k=1 \cdots N_z)$
%%  \\\hspace{1.0cm}
%%  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
%%  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^*$,
%%  ${\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{\rm old}$,
%%  ${\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{{\rm old} *}$
%%  \\\hspace{0.5cm}
%%  \verb|BiCG_update2| finish
%%\end{leftbar}
%%\hspace{0.5cm}
%%if($|{\boldsymbol v}_2| < $Threshold) exit
%%\\
%%end do iteration
%%\begin{leftbar}
%%  \verb|BiCG_finalize| start
%%  \\ \hspace{0.5cm}
%%  Deallocate ${\boldsymbol v}_3$, ${\boldsymbol v}_4$, ${\boldsymbol v}_5$, 
%%  $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
%%  \\
%%  \verb|BiCG_finalize| finish
%%\end{leftbar}

\subsection{Shifted COCGライブラリの動作イメージ}

\noindent
Allocate ${\boldsymbol v}_1$, ${\boldsymbol v}_2$, $\{{\bf x}_k\}, {\bf r}^{\rm L}$
\\ 
${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_init(N_H, N_L, N_z, x, z)| start
  \\ \hspace{0.5cm}
  Allocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\ \hspace{0.5cm}
  Copy $\{z_k\}$
  \\ \hspace{0.5cm}
  \verb|itermax|$\neq$\verb|0|ならば$\alpha$, $\beta$, ${\bf r}^{\rm L}$を保存する配列を確保する.
  \\ \hspace{0.5cm}
  ${\boldsymbol v}_3 = {\bf 0}$,
  \\ \hspace{0.5cm}
  ${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$ 
  \\ \hspace{0.5cm}
  $\rho = \infty,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0$ 
  \\ \hspace{0.5cm}
  (
  ${\boldsymbol v}_2 \equiv {\boldsymbol r}$, 
  ${\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$. )
  \\
  \verb|COCG_init| finish
\end{leftbar}
\vspace{-1em}
\noindent
do iteration
\\\hspace{0.5cm}
${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$
\\\hspace{0.5cm}
${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$
\vspace{-1em}
\begin{leftbar}
  \noindent
  \hspace{0.5cm}
  \verb|COCG_update(v_1, v_2, x, p, r_small)| start
  \\\hspace{1.0cm}
  $\circ$シード方程式
  \\\hspace{1.0cm}
  $\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2$
  \\\hspace{1.0cm}
  $\beta = \rho / \rho^{\rm old}$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\alpha^{\rm old} = \alpha,\; 
  \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }$
  \\\hspace{1.0cm}
  $\circ$シフト方程式
  \\\hspace{1.0cm}
  do $k = 1 \cdots N_z$
  \\\hspace{1.5cm}
  $\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$
  \\\hspace{1.5cm}
  ${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
  \left|\frac{\pi^{\rm old}_k}{\pi_k } \right|^2 \beta {\bf p}_{k}$
  \\\hspace{1.5cm}
  ${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$
  \\\hspace{1.5cm}
  $\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}$
  \\\hspace{1.0cm}
  end do $k$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
  - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$
  \\\hspace{1.0cm}
  ${\boldsymbol v}_3 = {\boldsymbol v}_2$,
  ${\boldsymbol v}_2 = {\boldsymbol v}_1$
  \\\hspace{1.0cm}
  $\circ$ Seed switch
  \\\hspace{1.0cm}
  $|\pi_k|$が最も小さい$k$を探す. 
  $\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old} $
  \\\hspace{1.0cm}
  ${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}$,
  ${\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$
  \\\hspace{1.0cm}
  $\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha$,
  $\rho = \rho / |\pi_{\rm seed}^{\rm old}|^2$
  \\\hspace{1.0cm}
  $\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$
  \\\hspace{0.5cm}
  \verb|COCG_update| finish
\end{leftbar}
\vspace{-1em}
\noindent
\hspace{0.5cm}
if($|{\boldsymbol v}_2| < $Threshold) exit
\\
end do iteration
\vspace{-1em}
\begin{leftbar}
  \noindent
  \verb|COCG_finalize| start
  \\ \hspace{0.5cm}
  Deallocate ${\boldsymbol v}_3$, $\{\pi_k\}$, $\{\pi_k^{\rm old}\}$, $\{{\bf p}_k\}$
  \\
  \verb|COCG_finalize| finish
\end{leftbar}
\vspace{-1em}

\subsection{Shifted CGライブラリの動作イメージ}

COCGと同様.

\section{使用方法}

各ライブラリともユーザーはライブラリ名および型を指定し、
\begin{itemize}
\item 初期設定 (init関数)
\item アップデート (update関数)
\item 計算情報出力 (getcoef, getvec関数などを呼び出力)
\item 終了関数 (finalize関数)
\end{itemize}
の手順で関数を使用することで、計算が実施される。
なお、リスタートを行う場合には
\begin{itemize}
\item 初期設定関数(init関数, restart関数)
\item アップデート (update関数)
\item 計算情報出力 (getcoef, getvec関数などを呼び出力)
\item 終了関数 (finalize関数)
\end{itemize}
の手順で実行する。
 
以下、代表的な例としてShifted BiCGライブラリの場合の使用方法を記載する。

\subsection{Shifted BiCGライブラリの使用方法}

\begin{lstlisting}
PROGRAM my_prog
  !
  USE shifted_krilov, ONLY : BiCG_init, BiCG_restart, BiCG_update, &
  &                          BiCG_getcoef, BiCG_getvec, BiCG_finalize
  USE my_module, ONLY : input_size, rhs_vector, input_restart, &
  &                     projection, matrix_product, &
  &                     output_restart, output_result
  !
  IMPLICIT NONE
  !
  INTEGER :: &
  & ndim,    & ! Size of Hilvert space
  & nz,      & ! Number of frequencies
  & nl,      & ! Number of Left vector
  & itermax, & ! Max. number of iteraction
  & itermin, & ! First iteration in this run
  & iter,    & ! Counter for Iteration
  & niter_old  ! Number of iteraction of previous run
  !
  REAL(8) :: &
  & threshold, & ! Convergence Threshold
  !
  COMPLEX(8) :: &
  & v12(:), v13(:), v2(:), v3(:), & ! (ndim): Working vector
  & rsmall(:), & ! (nl) : Projeccted residual vector 
  & x(:,:),    & ! (nl,nz) : Projected result 
  & z(:)         ! (nz): Frequency
  !
  ! Variables for Restart
  !
  COMPLEX(8) :: &
  & r(:), r_old(:), & ! (ndim) Residual vector in Current & Previous step
  & rtilde(:), rtilde_old(:), & ! (ndim) Shadow Residual vector
  & zseed, & ! Seed frequency
  & alpha(:), beta(:), & ! (niter_old) 
  & rsmall_save(:,:) ! (nl,niter_old) Projected residual vectors
  !
  LOGICAL :: lconverged ! .TRUE. if converged
  !
  ! Input Size of vectors
  !
  CALL input_size(ndim,nz,nl,itermax)
  !
  ALLOCATE(v12(ndim), v13(ndim), v2(ndim), v3(ndim), &
  &        rsmall(nl), x(nl,nz), z(nz)               )
  !
  ! Generate Right Hand Side Vector
  !
  CALL rhs_vector(ndim, v2)
  !
  ! Check: Whether the restart file is exist.
  !
  CALL input_restart(niter_old, r, r_old, r_tilde, r_old, &
  &                  alpha, beta, zseed, rsmall_save)
  !
  IF(niter_old > 0) THEN
    !
    ! When restarting, counter
    !
    itermin = niter_old + 1
    CALL BiCG_restart(ndim, nl, nz, v2, v3, x, z, itermax, &
    &                 threshold, r, r_old, r_tilde, r_old, &
    &                 alpha, beta, zseed, rsmall_save)
    !
    ! These vectors were saved in BiCG routine
    !
    DEALLOCATE(r, r_old, r_tilde, r_old, alpha, beta, zseed, rsmall_save)
    !
  ELSE
    itermin = 1
    CALL BiCG_init(ndim, nl, nz, v2, v3, x, z, itermax, threshold)
  END IF
  !
  ! BiCG Loop
  !
  DO iter = itermin, itermax
    !
    ! Projection of Residual vector into the space
    ! spaned by left vectors
    !
    CALL projection(ndim, nl, v2, rsmall)
    !
    ! Matrix-vector product
    !
    CALL matrix_product(v2, v12)
    CALL matrix_product(v3, v13)
    !
    ! Update result x with BiCG
    !
    CALL BiCG_update(v12, v13, v2, v3, x, rsmall, lconverged)
    !
    IF(lconverged == .true.) EXIT
    !
  END DO
  !
  ! Get these vectors for restart in the Next run
  !
  ALLOCATE(r(ndim), r_old(ndim), r_tilde(ndim), r_old(ndim), &
  &        alpha(iter), beta(iter), rsmall_save(nl,iter))
  !
  CALL BiCG_getcoef(alpha, beta, zseed, rsmall_save)
  CALL BiCG_getvec(r, r_old, rtilde, rtilde_old)
  !
  ! Deallocate all intrinsic vectors
  !
  CALL BiCG_finalize()
  !
  ! Output to a file
  !
  CALL output_restart(niter_old, r, r_old, r_tilde, r_old, &
  &                   alpha, beta, zseed, rsmall_save)
  !
  CALL output_result(z,x)
  !
  DEALLOCATE(r, r_old, r_tilde, r_old, alpha, beta, zseed, rsmall_save)
  DEALLOCATE(v12, v13, v2, v3, rsmall, x, z)
  !
END PROGRAM my_prog
\end{lstlisting}


\begin{thebibliography}{99}
\bibitem{BiCG}
  A. Frommer, Computing {\bf 70}, 87 (2003).
  
\bibitem{COCG}
  S. Yamamoto, T. Sogabe, T. Hoshi, S.-L. Zhang, and T. Fujiwara, J. Phys. Soc. Jpn. {\bf 77}, 114713 (2008).
\end{thebibliography}

\end{document}
