<html>
  <head>
    <meta http-equiv="Content-Type" 
          content="text/html; charset=utf-8">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
    
    <title>Komega日本語マニュアル</title>
    
    <meta name="description" content="Komega日本語マニュアル">
    
  </head>
  <body bgcolor="CCFFCC">

    <h1>4, プログラム内でのライブラリの動作イメージ</h1>

    <p>以下では$N_R$のループは省略する(各右辺ベクトルごとに同じ事をすればいいので).
      また$G_{i j}$($z_k$)の代わりに$N_z$個の$N_L$次元の解ベクトル${\bf x}_{k}$を求める.</p>
    
    <p>注意事項.</p>
    <ul>
      <li><p><code>komega_????_init</code>を呼び出す前に
      サイズ$N_H$のベクトルを2本(BiCGの時には4本)Allocateしておく.</p></li>
      <li><p>ハミルトニアン-ベクトル積を行う部分はあらかじめ作成しておく.</p></li>
      <li><p>解ベクトルをAllocateしておく. ただし, これは必ずしも$N_H$ × $N_z$である必要はない.
      実際前節の場合は$N_L \times N_z$である.
      この時(双)共役勾配ベクトル${{\bf p}_k}$も $N_z$個の$N_L$次元のベクトルである.
      $N_H$次元の残差ベクトルを$N_L$次元へ変換するところはユーザーが行う.</p>
    <p>
      $$\begin{aligned}
      {\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
      {\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
      \end{aligned}$$
    </p>
      </li>
      <li><p><code>komega_????_update</code>の出力<code>status</code>の
      第一成分が負の値になった場合には, 解が収束した, 若しくは破たんしたことを表す.
      したがって<code>status(1) &lt; 0</code>でループを抜けるようにしておく.</p>
      </li>
      <li><p><code>komega_????_update</code>内での収束判定には,
      シード点での残差ベクトルの2-ノルムが使われる.
      すなわち, すべてのシフト点での残差ベクトルの2-ノルムが<code>threshold</code>を
      下回った時に収束したと見做される.</p></li>
      <li><p>各iterationでの$\alpha, \beta, {\bf r}^{\rm L}$を保存しておき,
      あとで利用する場合には最大反復回数<code>itermax</code>を設定する.</p></li>
    </ul>
    
    <p>ライブラリの各ルーチンの名前は次の通りである.</p>
    <ul>
      <li>
        <p><code>komega_BiCG_init</code>, <code>komega_COCG_init</code>,
          <code>komega_CG_C_init</code>, <code>komega_CG_R_init</code></p>
        <p>ライブラリ内部で使う(ユーザーの目に触れない)変数のAllocateや初期値設定を行う.</p>
      </li>
      <li>
        <p><code>komega_BiCG_update</code>, <code>komega_COCG_update</code>,
          <code>komega_CG_C_update</code>, <code>komega_CG_R_update</code></p>
        <p>Iteration の中で呼び出される. 解ベクトル群の更新等を行う.</p>
      </li>
      <li>
        <p><code>komega_BiCG_finalize</code>, <code>komega_COCG_finalize</code>,
          <code>komega_CG_C_finalize</code>, <code>komega_CG_R_finalize</code></p>
        <p>Allocateしたライブラリ内部ベクトルを開放する.</p>
      </li>
      <li>
        <p><code>komega_BiCG_getcoef</code>, <code>komega_COCG_getcoef</code>,
          <code>komega_CG_C_getcoef</code>, <code>komega_CG_R_getcoef</code></p>
        <p>各iterationで保存しておいた$α$, $\beta$, $z_{\rm seed}$, ${\bf r}^{\rm L}$を取り出す.</p>
      </li>
      <li>
        <p><code>komega_BiCG_getvec</code>, <code>komega_COCG_getvec</code>,
          <code>komega_CG_C_getvec</code>, <code>komega_CG_R_getvec</code></p>
        <p>${\boldsymbol r}$, ${\boldsymbol r}^{\rm old}$, ${\tilde {\boldsymbol r}}$,
          ${\tilde {\boldsymbol r}}^{\rm old}$ を取り出す.</p>
      </li>
      <li>
        <p><code>komega_BiCG_restart</code>, <code>komega_COCG_restart</code>,
          <code>komega_CG_C_restart</code>, <code>komega_CG_R_restart</code></p>
        <p>保存しておいた$α$等を用いて, 新規の$z$での計算を行う. ${\boldsymbol r}$等も有る場合には
          <code>komega_BiCG_init</code>, <code>komega_COCG_init</code>,
          <code>komega_CG_C_init</code>, <code>komega_CG_R_init</code> の代わりに用いてリスタートすることもできる.</p>
      </li>
    </ul>
    
    <h2><a name="bicg">4.1, Shifted BiCGライブラリの動作イメージ</h2>
    
    <ul style="list-style:none">
      <li>Allocate ${\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 3},
        {\boldsymbol v}_2, {\boldsymbol v}_3, \{{\bf x}_k\}, {\bf r}^{\rm L}$</li>
      <li>${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$</li>
      <li><code>komega_BiCG_init(N_H, N_L, N_z, x, z, itermax, threshold)</code> start</li>
      <ul style="list-style:none">
        <li>Allocate ${\boldsymbol v}_3, {\boldsymbol v}_5, \{\pi_k\}, \{\pi_k^{\rm old}\}, \{{\bf p}_k\}$</li>
        <li>Copy $\{z_k\}$</li>
        <li><code>itermax</code> &ne; <code>0</code>ならば$\alpha, \beta, {\bf r}^{\rm L}$を保存する配列を確保する.</li>
        <li>${\boldsymbol v}_4 = {\boldsymbol v}_2^*$(任意), ${\boldsymbol v}_3 = {\boldsymbol v}_5 = {\bf 0}$,</li>
        <li>${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z), \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$</li>
        <li>$\rho = \infty, \alpha = 1, z_{\rm seed}=0$</li>
        <li>( ${\boldsymbol v}_2 \equiv {\boldsymbol r}, {\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}, {\boldsymbol v}_4 \equiv {\tilde {\boldsymbol r}}, {\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}$. )</li>
      </ul>
      <li><code>komega_BiCG_init</code> finish</li>
      <li>do iteration</li>
      <ul style="list-style:none">
        <li>${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$</li>
        <li>${\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2, {\boldsymbol v}_{1 4} = {\hat H} {\boldsymbol v}_4$ $ [ ({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4}) = {\hat H}
          ({\boldsymbol v}_2, {\boldsymbol v}_4)とも書ける]$</li>
        <li><code>komega_BiCG_update(v_12, v_2, v_14, v_4, x, r_small, status)</code> start</li>
        <ul style="list-style:none">
          <li> * シード方程式</li>
          <li>$\rho^{\rm old} = \rho, \rho = {\boldsymbol v}_4^* \cdot {\boldsymbol v}_2$</li>
          <li>$\beta = \rho / \rho^{\rm old}$</li>
          <li>${\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4} = z_{\rm seed}^* {\boldsymbol v}_4 - {\boldsymbol v}_{1 4}$</li>
          <li>$\alpha^{\rm old} = \alpha, 
            \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }$</li>
          <li> * シフト方程式</li>
          <li>do $k$ = 1$\cdots$$N_z$</li>
          <ul style="list-style:none">
            <li>$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$</li>
            <li>${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
              \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$</li>
            <li>${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$</li>
            <li>$\pi_k^{\rm old} = \pi_k, \pi_k = \pi_k^{\rm new}$</li>
          </ul>
          <li>end do $k$</li>
          <li>${\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
            - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3, {\boldsymbol v}_3 = {\boldsymbol v}_2,
            {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}$</li>
          <li>${\boldsymbol v}_{1 4} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} \right) {\boldsymbol v}_4
            - \alpha^* {\boldsymbol v}_{1 4} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5, {\boldsymbol v}_5 = {\boldsymbol v}_4, 
            {\boldsymbol v}_4 = {\boldsymbol v}_{1 4}$</li>
          <li> *  Seed switch</li>
          <li>∣$\pi_k$∣が最も小さい$k$を探す. $\rightarrow z_{\rm seed}, \pi_{\rm seed}, \pi_{\rm seed}^{\rm old} $</li>
          <li>${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}, {\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}, {\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{*}, {\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}$</li>
          <li>$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha, \rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$</li>
          <li>$\{\pi_k = \pi_k / \pi_{\rm seed}, \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$</li>
        </ul>
        <li><code>komega_BiCG_update</code> finish</li>
        <li>if(status(1) &lt; 0 (これは$|{\boldsymbol v}_2| &lt; $Threshold となった事を意味する)) exit</li>
      </ul>
      <li>end do iteration</li>
      <li><code>komega_BiCG_finalize</code> start</li>
      <ul style="list-style:none">
        <li>Deallocate ${\boldsymbol v}_4, {\boldsymbol v}_5, \{\pi_k\}, \{\pi_k^{\rm old}\}, \{{\bf p}_k\}$</li>
      </ul>
      <li><code>komega_BiCG_finalize</code> finish</li>
    </ul>
    
    <h2><a name="cocg">4.2, Shifted COCGライブラリの動作イメージ</h2>
    
    <ul style="list-style:none">
      <li>Allocate ${\boldsymbol v}_1, {\boldsymbol v}_2, \{{\bf x}_k\}, {\bf r}^{\rm L}$</li>
      <li>${\boldsymbol v}_2 = {\boldsymbol \varphi_j}$</li>
      <li><code>COCG_init(N_H, N_L, N_z, x, z, itermax, threshold)</code> start</li>
      <ul style="list-style:none">
        <li>Allocate ${\boldsymbol v}_3, \{\pi_k\}, \{\pi_k^{\rm old}\}, \{{\bf p}_k\}$</li>
        <li>Copy $\{z_k\}$</li>
        <li><code>itermax</code> &ne; <code>0</code>ならば$\alpha, \beta, {\bf r}^{\rm L}$を保存する配列を確保する.</li>
        <li>${\boldsymbol v}_3 = {\bf 0}$,</li>
        <li>${\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z), \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)$</li>
        <li>$\rho = \infty, \alpha = 1, \beta=0, z_{\rm seed}=0$</li>
        <li>( ${\boldsymbol v}_2 \equiv {\boldsymbol r}, {\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}$. )</li>
      </ul>
      <li><code>COCG_init</code> finish</li>
      <li>do iteration</li>
      <ul style="list-style:none">
        <li>${\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2$</li>
        <li>${\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2$</li>
        <li><code>COCG_update(v_1, v_2, x, r_small, status)</code> start</li>
        <ul style="list-style:none">
          <li> * シード方程式</li>
          <li>$\rho^{\rm old} = \rho, \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2$</li>
          <li>$\beta = \rho / \rho^{\rm old}$</li>
          <li>${\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1$</li>
          <li>$\alpha^{\rm old} = \alpha, 
            \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }$</li>
          <li> * シフト方程式</li>
          <li>do $k = 1 \cdots N_z$</li>
          <ul style="list-style:none">
            <li>$\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)$</li>
            <li>${\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + 
              \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}$</li>
            <li>${\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}$</li>
            <li>$\pi_k^{\rm old} = \pi_k, \pi_k = \pi_k^{\rm new}$</li>
          </ul>
          <li>end do $k$</li>
          <li>${\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2
            - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3$</li>
          <li>${\boldsymbol v}_3 = {\boldsymbol v}_2, {\boldsymbol v}_2 = {\boldsymbol v}_1$</li>
          <li> * Seed switch</li>
          <li>∣$\pi_k$∣が最も小さい$k$を探す. $\rightarrow z_{\rm seed}, \pi_{\rm seed}, \pi_{\rm seed}^{\rm old} $</li>
          <li>${\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}, {\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}$</li>
          <li>$\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha, \rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})$</li>
          <li>$\{\pi_k = \pi_k / \pi_{\rm seed}, \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}$</li>
        </ul>
        <li><code>COCG_update</code> finish</li>
        <li>if(status(1) &lt; 0 (これは$|{\boldsymbol v}_2| &lt; $Threshold となった事を意味する)) exit</li>
      </ul>
      <li>end do iteration</li>
      <li><code>COCG_finalize</code> start</li>
      <ul style="list-style:none">
        <li>Deallocate ${\boldsymbol v}_3, \{\pi_k\}, \{\pi_k^{\rm old}\}, \{{\bf p}_k\}$</li>
      </ul>
      <li><code>COCG_finalize</code> finish</li>
    </ul>
    
    <h2><a name="cg">4.3, Shifted CGライブラリの動作イメージ</h2>
    <p>COCGと同様.</p>
    
  </body>
</html>
