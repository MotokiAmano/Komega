<html>
  <head>
    <meta http-equiv="Content-Type" 
          content="text/html; charset=utf-8">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
    
    <title>Komega日本語マニュアル</title>
    
    <meta name="description" content="Komega日本語マニュアル">
    
  </head>
  <body bgcolor="CCFFCC">
    
    <h1>5, 使用方法</h1>

    <p>各ライブラリともユーザーはライブラリ名および型を指定し,</p>
    <ul>
      <li><p>初期設定 (init関数)</p></li>
      <li><p>アップデート (update関数)</p></li>
      <li><p>計算情報出力 (getcoef, getvec関数などを呼び出力)</p></li>
      <li><p>終了関数 (finalize関数)</p></li>
    </ul>
    <p>の手順で関数を使用することで, 計算が実施される. なお, リスタートを行う場合には</p>
    <ul>
      <li><p>初期設定関数(restart関数)</p></li>
      <li><p>アップデート (update関数)</p></li>
      <li><p>計算情報出力 (getcoef, getvec関数などを呼び出力)</p></li>
      <li><p>終了関数 (finalize関数)</p></li>
    </ul>
    <p>の手順で実行する. fortran から呼び出すときには</p>
    <pre><code>  USE komega_????</code></pre>
    <p>のようにモジュールを呼び出す.
      <code>&quot;????&quot;</code>の部分には, <code>&quot;CG_R&quot;</code>,
      <code>&quot;CG_C&quot;</code>, <code>&quot;COCG&quot;</code>, <code>&quot;BiCG&quot;</code>が入る.
      MPI/Hybrid並列版のルーチンを利用するときには,</p>
    <pre><code>  USE pkomega_????</code></pre>
    <p>のようにする.</p>
    <p>C/C++で書かれたプログラムから呼び出すときには、</p>
    <pre><code>#include komega_????.h</code></pre>
    <p>のようにヘッダーファイルを読み込む。 また、スカラー引数はすべてポインタとして渡す。
      MPI/Hybrid並列版のルーチンを利用するときには,</p>
    <pre><code>#include pkomega_????.h</code></pre>
    <p>のようにする。
      またライブラリに渡すコミュニケーター変数を、次のようにC/C++のものからfortranのものに変換する。</p>
    <pre><code>  comm_f = MPI_Comm_c2f(comm_c);</code></pre>
    
    <h2 id="各ルーチンの説明">各ルーチンの説明</h2>
    
    <h3 id="komega__init-pkomega__init"><code>komega_????_init</code>, <code>pkomega_????_init</code></h3>
    
    <p>ライブラリ内部変数の割り付けおよび初期化を行う.
      シフト線形方程式を解く前に, 一番初めに実行する.</p>
    
    <p>構文</p>
    <p>Fortran シリアル/OpenMP版</p>
    <pre><code>
CALL komega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_COCG_init(ndim, nl, nz, x, z, itermax, threshold)
CALL komega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold)
    </code></pre>
    <p>Fortran MPI/Hybrid並列版</p>
    <pre><code>
CALL pkomega_CG_R_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_CG_C_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_COCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)
CALL pkomega_BiCG_init(ndim, nl, nz, x, z, itermax, threshold, comm)
    </code></pre>
    <p>C/C++ シリアル/OpenMP版</p>
    <pre><code>
komega_CG_R_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold);
komega_CG_C_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold);
komega_COCG_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold);
komega_BiCG_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold);
    </code></pre>
    <p>C/C++ MPI/Hybrid並列版</p>
    <pre><code>
pkomega_CG_R_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm);
pkomega_CG_C_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm);
pkomega_COCG_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm);
pkomega_BiCG_init(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm);
    </code></pre>
    
    <p>パラメーター</p>
    <ul>
      <li><p><code>ndim</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. 線形方程式の次元.</p></li>
      <li><p><code>nl</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. 射影された解ベクトルの次元.</p></li>
      <li><p><code>nz</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. シフト点の数.</p></li>
      <li><p><code>x</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_init</code>の場合),
          <code>DOUBLE COMPLEX</code> (それ以外). 長さ <code>nl*nz</code>の配列. 出力. 解ベクトル.
          <code>0</code>ベクトルが返される.</p></li>
      <li><p><code>z</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_init</code>, <code>CG_C_init</code>の場合),
          <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>nz</code>の配列. 入力. シフト点.</p>
      </li>
      <li><p><code>itermax</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. リスタート用配列の割り付けのための最大反復回数.
          これを<code>0</code>にした場合にはリスタート用配列を割りつけない
          (したがって後述のリスタート用変数の出力を行えない)</p>
      </li>
      <li><p><code>threshold</code></p>
        <p><code>DOUBLE PRECISION</code>. スカラー. 入力. 収束判定用しきい値.
          シード方程式の残差ベクトルの2-ノルムがこの値を下回った時に収束したと判定する.</p>
      </li>
      <li><p><code>comm</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. MPI/Hybrid並列版のみ.
          MPIのコミニュケーター(<code>MPI_COMM_WORLD</code>など)を入れる.</p>
      </li>
    </ul>
    
    <h3 id="komega__restart-pkomega__restart"><code>komega_????_restart</code>,
      <code>pkomega_????_restart</code></h3>
    <p>リスタートを行う場合に<code>?_init</code>の代わりに用いる.
      ライブラリ内部変数の割り付けおよび初期化を行う. シフト線形方程式を解く前に, 一番初めに実行する.</p>
    
    <p>構文</p>
    <p>Fortran (シリアル/OpenMP版)</p>
    <pre><code>
CALL komega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL komega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, status, &amp;
&amp;                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &amp;
&amp;                 z_seed, r_l_save)
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_CG_C_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_COCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &amp;
&amp;                 iter_old, v2, v12, alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_BiCG_restart(ndim, nl, nz, x, z, itermax, threshold, comm, status, &amp;
&amp;                 iter_old, v2, v12, v4, v14, alpha_save, beta_save, &amp;
&amp;                 z_seed, r_l_save)
    </code></pre>
    <p>C/C++ (シリアル/OpenMP版)</p>
    <pre><code>
komega_CG_R_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_CG_C_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_COCG_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_BiCG_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, status, &amp;
&amp;                 &amp;iter_old, v2, v12, v4, v14, alpha_save, beta_save, &amp;
&amp;                 &amp;z_seed, r_l_save);
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_CG_C_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_COCG_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm, status, &amp;
&amp;                 &amp;iter_old, v2, v12, alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_BiCG_restart(&amp;ndim, &amp;nl, &amp;nz, x, z, &amp;itermax, &amp;threshold, &amp;comm, status, &amp;
&amp;                 &amp;iter_old, v2, v12, v4, v14, alpha_save, beta_save, &amp;
&amp;                 &amp;z_seed, r_l_save);
    </code></pre>
    
    <p>パラメーター</p>
    
    <ul>
      <li><p><code>ndim, nl, nz, x, z, itermax, threshold, comm</code></p>
        <p><code>?_init</code>と同様.</p></li>
      <li><p><code>status</code></p>
        <p><code>INTEGER</code>. 長さ<code>3</code>の配列. 出力. エラーコードを返す.</p>
        <dl>
          <dt>第一成分(<code>status(1)</code>)</dt>
          <dd><p>解が収束した場合, もしくは計算が破綻した場合には現在の総反復回数に マイナスが付いた値が返される. それ以外の場合には現在の総反復回数(マイナスが付かない)が返される. <code>status(1)</code>が正の値の時のみ反復を続行できる. それ以外の場合は反復を進めても有意な結果は得られない.</p>
          </dd>
          <dt>第二成分(<code>status(2)</code>)</dt>
          <dd><p><code>itermax</code>を有限にして, かつ<code>itermax</code>回の反復で 収束に達しなかった場合には<code>1</code>が返される. $\alpha$が発散した場合には<code>2</code>が返される. $\pi_{\rm seed}$が0にになった場合には<code>3</code>が返される. <code>COCG_restart</code>もしくは<code>BiCG_restart</code>で, 残差ベクトルと影の残差ベクトルが直交した場合には<code>4</code>が返される. それ以外の場合には<code>0</code>が返される.</p>
          </dd>
          <dt>第三成分(<code>status(3)</code>)</dt>
          <dd><p>シード点のindexが返される.</p>
          </dd>
      </dl></li>
      <li><p><code>iter_old</code></p>
        <p><code>INTEGER</code>. スカラー. 入力. 先行する計算での反復回数.</p></li>
      <li><p><code>v2</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>ndim</code>の配列. 入力. 先行する計算での最後の残差ベクトル.</p></li>
      <li><p><code>v12</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>ndim</code>の配列. 入力. 先行する計算での最後から2番目の残差ベクトル.</p></li>
      <li><p><code>alpha_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>, <code>CG_C_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>iter_old</code>の配列. 入力. 先行する計算での各反復での(Bi)CG法のパラメーター$\alpha$.</p></li>
      <li><p><code>beta_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>, <code>CG_C_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>iter_old</code>の配列. 入力. 先行する計算での各反復での(Bi)CG法のパラメーター$\beta$.</p></li>
      <li><p><code>z_seed</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>, <code>CG_C_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). スカラー. 入力. 先行する計算でのシードシフト.</p></li>
      <li><p><code>r_l_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_restart</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>nl*iter_old</code>の配列. 入力. 先行する計算での各反復での射影された残差ベクトル.</p></li>
      <li><p><code>v4</code></p>
        <p><code>BiCG_restart</code>の場合のみ使用. <code>DOUBLE COMPLEX</code>. 長さ<code>ndim</code>の配列. 入力. 先行する計算での最後の影の残差ベクトル.</p></li>
      <li><p><code>v14</code></p>
        <p><code>BiCG_restart</code>の場合のみ使用. <code>DOUBLE COMPLEX</code>. 長さ<code>ndim</code>の配列. 入力. 先行する計算での最後から2番目の影の残差ベクトル.</p></li>
    </ul>
    
    <h3 id="komega__update-pkomega__update"><code>komega_????_update</code>, <code>pkomega_????_update</code></h3>
    
    <p>ループ内で行列ベクトル積と交互に呼ばれて解を更新する.</p>
    <p>構文</p>
    <p>Fortran (シリアル/OpenMPI版)</p>
    <pre><code>
CALL komega_CG_R_update(v12, v2, x, r_l, status)
CALL komega_CG_C_update(v12, v2, x, r_l, status)
CALL komega_COCG_update(v12, v2, x, r_l, status)
CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_update(v12, v2, x, r_l, status)
CALL pkomega_CG_C_update(v12, v2, x, r_l, status)
CALL pkomega_COCG_update(v12, v2, x, r_l, status)
CALL pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
    </code></pre>
    <p>C/C++ (シリアル/OpenMPI版)</p>
    <pre><code>
komega_CG_R_update(v12, v2, x, r_l, status);
komega_CG_C_update(v12, v2, x, r_l, status);
komega_COCG_update(v12, v2, x, r_l, status);
komega_BiCG_update(v12, v2, v14, v4, x, r_l, status);
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_update(v12, v2, x, r_l, status);
pkomega_CG_C_update(v12, v2, x, r_l, status);
pkomega_COCG_update(v12, v2, x, r_l, status);
pkomega_BiCG_update(v12, v2, v14, v4, x, r_l, status);
    </code></pre>
    
    <p>パラメーター</p>
    <ul>
      <li><p><code>v12</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_update</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>ndim</code>の配列. 入出力. 入力は残差ベクトル(<code>v2</code>)と行列の積. 出力は, 更新された残差ベクトルの2-ノルムが, 先頭の要素に格納される(これは収束の具合を表示して調べる時などに用いる).</p></li>
      <li><p><code>v2</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_update</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>ndim</code>の配列. 入出力. 入力は残差ベクトル. 出力は更新された残差ベクトル.</p></li>
      <li><p><code>v14</code></p>
        <p><code>BiCG_update</code>の場合のみ使用. <code>DOUBLE COMPLEX</code>. 長さ<code>ndim</code>の配列. 入力. 影の残差ベクトル(<code>v4</code>)と行列の積.</p></li>
      <li><p><code>v4</code></p>
        <p><code>BiCG_update</code>の場合のみ使用. <code>DOUBLE COMPLEX</code>. 長さ<code>ndim</code>の配列. 入出力. 入力は影の残差ベクトル. 出力は更新された影の残差ベクトル.</p></li>
      <li><p><code>status</code></p>
        <p><code>INTEGER</code>. 長さ<code>3</code>の配列. 出力. エラーコードを返す.</p>
        <dl>
          <dt>第一成分(<code>status(1)</code>)</dt>
          <dd><p>解が収束した場合, もしくは計算が破綻した場合には現在の総反復回数に マイナスが付いた値が返される. それ以外の場合には現在の総反復回数(マイナスが付かない)が返される. <code>status(1)</code>が正の値の時のみ反復を続行できる. それ以外の場合は反復を進めても有意な結果は得られない.</p>
          </dd>
          <dt>第二成分(<code>status(2)</code>)</dt>
          <dd><p><code>?_init</code>ルーチンで, <code>itermax</code>を有限にして, かつ<code>itermax</code>回の反復で 収束に達しなかった場合には<code>1</code>が返される. $\alpha$が発散した場合には<code>2</code>が返される. $\pi_{\rm seed}$が0にになった場合には<code>3</code>が返される. <code>COCG_update</code>もしくは<code>BiCG_update</code>で, 残差ベクトルと影の残差ベクトルが直交した場合には<code>4</code>が返される. それ以外の場合には<code>0</code>が返される.</p>
          </dd>
          <dt>第三成分(<code>status(3)</code>)</dt>
          <dd><p>シード点のindexが返される.</p>
          </dd>
      </dl></li>
    </ul>
    <h3 id="komega__getcoef-pkomega__getcoef"><code>komega_????_getcoef</code>, <code>pkomega_????_getcoef</code></h3>
    <p>後でリスタートを刷るときに必要な係数を取得する. このルーチンを呼び出すためには, <code>?_init</code>ルーチンで<code>itermax</code>を<code>0</code>以外の値にしておく必要がある.</p>
    <p>構文</p>
    <p>Fortran (シリアル/OpenMP版)</p>
    <pre><code>
CALL komega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL komega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_CG_C_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_COCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
CALL pkomega_BiCG_getcoef(alpha_save, beta_save, z_seed, r_l_save)
    </code></pre>
    <p>C/C++ (シリアル/OpenMP版)</p>
    <pre><code>
komega_CG_R_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_CG_C_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_COCG_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
komega_BiCG_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_CG_C_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_COCG_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
pkomega_BiCG_getcoef(alpha_save, beta_save, &amp;z_seed, r_l_save);
    </code></pre>
    <p>パラメーター</p>
    <ul>
      <li><p><code>alpha_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_getoef</code>, <code>CG_C_getoef</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 総反復回数と同じ長さの配列. 出力. 各反復での(Bi)CG法のパラメーター$\alpha$.</p></li>
      <li><p><code>beta_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_getoef</code>, <code>CG_C_getoef</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 総反復回数と同じ長さの配列. 出力. 各反復での(Bi)CG法のパラメーター$\beta$.</p></li>
      <li><p><code>z_seed</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_getoef</code>, <code>CG_C_getoef</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). スカラー. 出力. シードシフト.</p></li>
      <li><p><code>r_l_save</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_getoef</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). <code>nl</code> × 総反復回数の長さ配列. 出力. 各反復での射影された残差ベクトル.</p></li>
    </ul>
    <h3 id="komega__getvec-pkomega__getvec"><code>komega_????_getvec</code>, <code>pkomega_????_getvec</code></h3>
    <p>後でリスタートをするときに必要な残差ベクトルを取得する. このルーチンを呼び出すためには, <code>?_init</code>ルーチンで<code>itermax</code>を<code>0</code>以外の値にしておく必要がある.</p>
    <p>構文</p>
    <p>Fortran (シリアル/OpenMP版)</p>
    <pre><code>
CALL komega_CG_R_getvec(r_old)
CALL komega_CG_C_getvec(r_old)
CALL komega_COCG_getvec(r_old)
CALL komega_BiCG_getvec(r_old, r_tilde_old)
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_getvec(r_old)
CALL pkomega_CG_C_getvec(r_old)
CALL pkomega_COCG_getvec(r_old)
CALL pkomega_BiCG_getvec(r_old, r_tilde_old)
    </code></pre>
    <p>C/C++ (シリアル/OpenMP版)</p>
    <pre><code>
komega_CG_R_getvec(r_old);
komega_CG_C_getvec(r_old);
komega_COCG_getvec(r_old);
komega_BiCG_getvec(r_old, r_tilde_old);
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_getvec(r_old);
pkomega_CG_C_getvec(r_old);
pkomega_COCG_getvec(r_old);
pkomega_BiCG_getvec(r_old, r_tilde_old);
    </code></pre>

    <p>パラメーター</p>
    <ul>
      <li><p><code>r_old</code></p>
        <p><code>DOUBLE PRECISION</code> (<code>CG_R_getvec</code>の場合), <code>DOUBLE COMPLEX</code> (それ以外). 長さ<code>ndim</code>の配列. 出力. 先行する計算での最後から2番目の残差ベクトル.</p></li>
      <li><p><code>r_tilde_old</code></p>
        <p><code>BiCG_getvec</code>の場合のみ使用. <code>DOUBLE COMPLEX</code>. 長さ<code>ndim</code>の配列. 出力. 先行する計算での最後から2番目の影の残差ベクトル.</p></li>
    </ul>
    
    <h3 id="komega__getresidual-pkomega__getresidual">
      <code>komega_????_getresidual</code>, <code>pkomega_????_getresidual</code></h3>

    <p>各シフト点での残差ベクトルの2-ノルムを取得する.
      このルーチンは<code>komega_????_init</code>と<code>komega_????_finalize</code>
      の間の任意の場所で呼び出すことが出来る.
      また, いつ何回呼び出しても最終的な計算結果には影響を与えない.</p>
    <p>構文</p>
    <p>Fortran (シリアル/OpenMP版)</p>
    <pre><code>
CALL komega_CG_R_getresidual(res)
CALL komega_CG_C_getresidual(res)
CALL komega_COCG_getresidual(res)
CALL komega_BiCG_getresidual(res)
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_getresidual(res)
CALL pkomega_CG_C_getresidual(res)
CALL pkomega_COCG_getresidual(res)
CALL pkomega_BiCG_getresidual(res)
    </code></pre>
    <p>C/C++ (シリアル/OpenMP版)</p>
    <pre><code>
komega_CG_R_getresidual(res);
komega_CG_C_getresidual(res);
komega_COCG_getresidual(res);
komega_BiCG_getresidual(res);
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_getresidual(res);
pkomega_CG_C_getresidual(res);
pkomega_COCG_getresidual(res);
pkomega_BiCG_getresidual(res);
    </code></pre>
    
    <p>パラメーター</p>
    <ul>
      <li><p><code>res</code></p>
        <p><code>DOUBLE PRECISION</code>. 長さ<code>nz</code>の配列. 出力. 各シフト点での残差ベクトルの2-ノルム.</p></li>
    </ul>
    
    <h3 id="komega__finalize-pkomega__finalize">
      <code>komega_????_finalize</code>, <code>pkomega_????_finalize</code></h3>

    <p>ライブラリ内部で割りつけた配列のメモリを解放する.</p>
    <p>構文</p>
    <p>Fortran (シリアル/OpenMP版)</p>
    <pre><code>
CALL komega_CG_R_finalize()
CALL komega_CG_C_finalize()
CALL komega_COCG_finalize()
CALL komega_BiCG_finalize()
    </code></pre>
    <p>Fortran (MPI/ハイブリッド並列版)</p>
    <pre><code>
CALL pkomega_CG_R_finalize()
CALL pkomega_CG_C_finalize()
CALL pkomega_COCG_finalize()
CALL pkomega_BiCG_finalize()
    </code></pre>
    <p>C/C++ (シリアル/OpenMP版)</p>
    <pre><code>
komega_CG_R_finalize();
komega_CG_C_finalize();
komega_COCG_finalize();
komega_BiCG_finalize();
    </code></pre>
    <p>C/C++ (MPI/ハイブリッド並列版)</p>
    <pre><code>
pkomega_CG_R_finalize();
pkomega_CG_C_finalize();
pkomega_COCG_finalize();
pkomega_BiCG_finalize();
    </code></pre>
    
    <h2 id="shifted-bicgライブラリを使用したソースコードの例">Shifted BiCGライブラリを使用したソースコードの例</h2>

    <p>以下, 代表的な例としてShifted BiCGライブラリの場合の使用方法を記載する.</p>

    <pre><code>
PROGRAM my_prog
  !
  USE komega_bicg, ONLY : komega_BiCG_init, komega_BiCG_restart, komega_BiCG_update, &amp;
  &amp;                       komega_BiCG_getcoef, komega_BiCG_getvec, komega_BiCG_finalize
  USE solve_cc_routines, ONLY : input_size, input_restart, &amp;
  &amp;                             projection, &amp;
  &amp;                             hamiltonian_prod, generate_system, &amp;
  &amp;                             output_restart, output_result
  !
  IMPLICIT NONE
  !
  INTEGER,SAVE :: &amp;
  &amp; rnd_seed, &amp;
  &amp; ndim,    &amp; ! Size of Hilvert space
  &amp; nz,      &amp; ! Number of frequencies
  &amp; nl,      &amp; ! Number of Left vector
  &amp; itermax, &amp; ! Max. number of iteraction
  &amp; iter_old   ! Number of iteraction of previous run
  !
  REAL(8),SAVE :: &amp;
  &amp; threshold ! Convergence Threshold
  !
  COMPLEX(8),SAVE :: &amp;
  &amp; z_seed ! Seed frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &amp;
  &amp; z(:)         ! (nz): Frequency
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &amp;
  &amp; ham(:,:), &amp;
  &amp; rhs(:), &amp;
  &amp; v12(:), v2(:), &amp; ! (ndim): Working vector
  &amp; v14(:), v4(:), &amp; ! (ndim): Working vector
  &amp; r_l(:), &amp; ! (nl) : Projeccted residual vector 
  &amp; x(:,:) ! (nl,nz) : Projected result 
  !
  ! Variables for Restart
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &amp;
  &amp; alpha(:), beta(:) ! (iter_old) 
  !
  COMPLEX(8),ALLOCATABLE,SAVE :: &amp;
  &amp; r_l_save(:,:) ! (nl,iter_old) Projected residual vectors
  !
  ! Variables for Restart
  !
  INTEGER :: &amp;
  &amp; itermin, &amp; ! First iteration in this run
  &amp; iter,    &amp; ! Counter for Iteration
  &amp; status(3)
  !
  ! Input Size of vectors
  !
  CALL input_size(ndim,nl,nz)
  !
  ALLOCATE(v12(ndim), v2(ndim), v14(ndim), v4(ndim), r_l(nl), &amp;
  &amp;        x(nl,nz), z(nz), ham(ndim,ndim), rhs(ndim))
  !
  CALL generate_system(ndim, ham, rhs, z)
  !
  ! Check: Whether the restart file is exist.
  !
  CALL input_restart(iter_old, zseed, alpha, beta, r_l_save)
  !
  WRITE(*,*)
  WRITE(*,*) &quot;#####  CG Initialization  #####&quot;
  WRITE(*,*)
  !
  IF(iter_old &gt; 0) THEN
    !
    ! When restarting, counter
    !
    itermin = iter_old + 1
    CALL komega_BiCG_restart(ndim, nl, nz, x, z, max(0,itermax), threshold, &amp;
    &amp;                 status, iter_old, v2, v12, v4, v14, alpha, &amp;
    &amp;                 beta, z_seed, r_l_save)
    !
    ! These vectors were saved in BiCG routine
    !
    DEALLOCATE(alpha, beta, r_l_save)
    !
    IF(status(1) /= 0) GOTO 10
    !
  ELSE
     !
     itermin = 1
     !
     ! Generate Right Hand Side Vector
     !
     v2(1:ndim) = rhs(1:ndim)
     v4(1:ndim) = CONJG(v2(1:ndim))
     !v4(1:ndim) = v2(1:ndim)
     !
     CALL komega_BiCG_init(ndim, nl, nz, x, z, max(0,itermax), threshold)
     !
  END IF
  !
  ! BiCG Loop
  !
  WRITE(*,*)
  WRITE(*,*) &quot;#####  CG Iteration  #####&quot;
  WRITE(*,*)
  !
  DO iter = 1, abs(itermax)
     !
     ! Projection of Residual vector into the space
     ! spaned by left vectors
     !
     r_l(1:nl) = projection(v2(1:nl))
     !
     ! Matrix-vector product
     !
     CALL hamiltonian_prod(Ham, v2, v12)
     CALL hamiltonian_prod(Ham, v4, v14)
     !
     ! Update result x with BiCG
     !
     CALL komega_BiCG_update(v12, v2, v14, v4, x, r_l, status)
     !
     WRITE(*,&#39;(a,i,a,3i,a,e15.5)&#39;) &quot;lopp : &quot;, iter, &amp;
     &amp;                             &quot;, status : &quot;, status(1:3), &amp;
     &amp;                             &quot;, Res. : &quot;, DBLE(v12(1))
     IF(status(1) &lt; 0) EXIT
     !
  END DO
  !
  IF(status(2) == 0) THEN
     WRITE(*,*) &quot;  Converged in iteration &quot;, ABS(status(1))
  ELSE IF(status(2) == 1) THEN
     WRITE(*,*) &quot;  Not Converged in iteration &quot;, ABS(status(1))
  ELSE IF(status(2) == 2) THEN
     WRITE(*,*) &quot;  Alpha becomes infinity&quot;, ABS(status(1))
  ELSE IF(status(2) == 3) THEN
     WRITE(*,*) &quot;  Pi_seed becomes zero&quot;, ABS(status(1))
  ELSE IF(status(2) == 4) THEN
     WRITE(*,*) &quot;  Residual &amp; Shadow residual are orthogonal&quot;, ABS(status(1))
  END IF
  iter_old = ABS(status(1))
  !
  ! Get these vectors for restart in the Next run
  !
  IF(itermax &gt; 0) THEN
     !
     ALLOCATE(alpha(iter_old), beta(iter_old), r_l_save(nl,iter_old))
     !
     CALL komega_BiCG_getcoef(alpha, beta, z_seed, r_l_save)
     CALL komega_BiCG_getvec(v12,v14)
     !
     CALL output_restart(iter_old, z_seed, alpha, beta, &amp;
     &amp;                   r_l_save, v12, v14)
     !
     DEALLOCATE(alpha, beta, r_l_save)
     !     
  END IF
  !
10 CONTINUE
  !
  ! Deallocate all intrinsic vectors
  !
  CALL komega_BiCG_finalize()
  !
  ! Output to a file
  !
  CALL output_result(nl, nz, z, x, r_l)
  !
  DEALLOCATE(v12, v2, v14, v4, r_l, x, z)
  !
  WRITE(*,*)
  WRITE(*,*) &quot;#####  Done  #####&quot;
  WRITE(*,*)
  !
END PROGRAM my_prog
    </code></pre>

  </body>
</html>
