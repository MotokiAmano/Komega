% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,dvipdfmx,openany]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{times}

\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{pxjahyper}

\title{$K\omega$ マニュアル}
\date{2017 年 06 月 13 日}
\release{2.0.0}
\author{}
\newcommand{\sphinxlogo}{\includegraphics{komega.png}\par}
\renewcommand{\releasename}{リリース}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{概要}
\label{komega_overview_ja::doc}\label{komega_overview_ja:welcome-to-s-documentation}\label{komega_overview_ja:id1}
本資料はISSP Math
Libraryの内の、Krylov部分空間法に基づくシフト線形方程式群ソルバーライブラリ
\(K\omega\)に関するマニュアルである. 本ライブラリは,
(射影付き)シフト線形問題
\begin{gather}
\begin{split}\begin{align}
  G_{i j}(z) = \langle i | (z {\hat I} -{\hat H})^{-1}| j \rangle \equiv
  {\boldsymbol \varphi}_i^{*} \cdot (z{\hat I}-{\hat H})^{-1} {\boldsymbol \varphi}_j
  \end{align}\end{split}\notag
\end{gather}
を, Krylov部分空間法を用いて解くためのルーチンを提供する.
言語はfortranを用いる. また, BLASレベル1ルーチンを使用する.


\chapter{アルゴリズム}
\label{komega_algorithm_ja::doc}\label{komega_algorithm_ja:id1}
このライブラリは,
\({\hat H}\) および \(z\) が複素数であるか実数であるかに応じて,
次の4種類の計算をサポートする( \({\hat H}\) は複素数の場合はエルミート行列,
実数の場合は実対称行列).
\begin{itemize}
\item {} 
\({\hat H}\) も \(z\) も両方複素数の場合 : Shifted
Bi-Conjugate Gradient(BiCG)法 {\hyperref[komega_ref_ja:ref]{\emph{{[}1{]}}}}

\item {} 
\({\hat H}\) が実数で \(z\) が複素数の場合 : Shifted
Conjugate Orthogonal Conjugate Gradient(COCG)法 {\hyperref[komega_ref_ja:ref]{\emph{{[}2{]}}}}

\item {} 
\({\hat H}\) が複素数で \(z\) が実数の場合 : Shifted
Conjugate Gradient(CG)法 (複素ベクトル)

\item {} 
\({\hat H}\) も \(z\) も両方実数の場合 : Shifted Conjugate
Gradient(CG)法 (実ベクトル)

\end{itemize}

いずれの場合も Seed switching {\hyperref[komega_ref_ja:ref]{\emph{{[}2{]}}}} を行う. 左ベクトルが \(N_L\) 個,
右ベクトルが \(N_R\) 個(典型的には1個)あるとする. 以下,
各手法のアルゴリズムを記載する.


\section{Seed switch 付き Shifted BiCG法}
\label{komega_algorithm_ja:seed-switch-shifted-bicg}
\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\),

\({\tilde {\boldsymbol r}} =\) 任意,
\({\boldsymbol r}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) シード方程式

\(\rho^{\rm old} = \rho,\; \rho = {\tilde {\boldsymbol r}}^* \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\tilde {\boldsymbol r}}^*\cdot{\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) シフト方程式

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\({\boldsymbol q} = (z_{\rm seed}^* {\hat I} - {\hat H}) {\tilde {\boldsymbol r}},\; {\boldsymbol q} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old}*}} \right) {\tilde {\boldsymbol r}} - \alpha^* {\boldsymbol q} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\tilde {\boldsymbol r}}^{\rm old},\; {\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}},\; {\tilde {\boldsymbol r}} = {\boldsymbol q}\)

\(\circ\) Seed switch

\(|\pi_k|\) が最も小さい \(k\) を探す. \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old},\; {\tilde {\boldsymbol r}} = {\tilde {\boldsymbol r}} / \pi_{\rm seed}^*,\; {\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} / \pi_{\rm seed}^{{\rm old}*}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\section{Seed switch 付き Shifted COCG法}
\label{komega_algorithm_ja:seed-switch-shifted-cocg}
BiCGのアルゴリズムで,
\({\tilde {\boldsymbol r}} = {\boldsymbol r}^*,\; {\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{{\rm old}*}\) とすると得られる.

\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\), \({\boldsymbol r}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) シード方程式

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r} \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol r}\cdot{\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) シフト方程式

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\(\circ\) Seed switch

\(|\pi_k|\) が最も小さい \(k\) を探す. \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\section{Seed switch 付き Shifted CG法}
\label{komega_algorithm_ja:seed-switch-shifted-cg}
BiCGのアルゴリズムで,
\({\tilde {\boldsymbol r}} = {\boldsymbol r},\; {\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{\rm old}\) とすると得られる.

\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\), \({\boldsymbol r}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) シード方程式

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r}^* \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol r}^* \cdot {\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) シフト方程式

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \left(\frac{\pi^{\rm old}_k}{\pi_k } \right)^2 \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\(\circ\) Seed switch

\(|\pi_k|\) が最も小さい \(k\) を探す. \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / {\pi_{\rm seed}^{\rm old}}^2\)

\(\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old}/\pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\chapter{インストール方法}
\label{komega_install_ja::doc}\label{komega_install_ja:id1}

\section{大まかな手順}
\label{komega_install_ja:id2}
最もシンプルには次のとおりである.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }./configure \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}install\PYGZus{}dir
\end{Verbatim}

これにより, ビルドに必要なコンパイラやライブラリ等の環境のチェックが行われ,
Makefile等が作成される.
ただし \code{install\_dir} はインストール先のディレクトリの絶対パスとする (以後各自のディレクトリ名で読み替えること).
なにも指定しないと \code{/use/local/} が設定され, 後述の \code{make install} で
\code{/usr/local/lib} 内にライブラリが置かれる (したがって, 管理者権限がない場合には \code{install\_dir} を
別の場所に指定しなければならない).
\code{configure} にはこの他にも様々なオプションがあり,必要に応じて用途や環境に合わせてそれらを使用する.
詳しくは {\hyperref[komega_install_ja:configoption]{\emph{configureのオプション}}} を参照.

\code{configure} の実行が正常に行われ, \code{Makefile} が生成された後は

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make
\end{Verbatim}

とタイプしてライブラリ等のビルドを行う.これが成功したのちに

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make install
\end{Verbatim}

とすると, ライブラリが \code{install\_dir/lib} に, ミニアプリが \code{install\_dir/bin} に置かれる.
\code{make install} をしなくても, ビルドをしたディレクトリ内にあるライブラリやミニアプリを使うことは可能であるが,
使い勝手がやや異なる.

共有リンクを行ったプログラムの実行時にライブラリを探しにいけるよう,
環境変数 \code{LD\_LIBRARY\_PATH} に \(K\omega\) をインストールしたディレクトリを追加する.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{export }\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{k}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{k}{\PYGZcb{}}:install\PYGZus{}dir/lib
\end{Verbatim}


\section{configureのオプション}
\label{komega_install_ja:configoption}\label{komega_install_ja:configure}
configureには多数のオプションと変数があり, それらを組み合わせて指定する.
指定しない場合にはデフォルト値が使われる.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }./configure \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/home/komega/ \PYGZhy{}\PYGZhy{}with\PYGZhy{}mpi\PYG{o}{=}yes \PYG{n+nv}{FC}\PYG{o}{=}mpif90
\end{Verbatim}

おもなものを次に挙げる.

\code{-{-}-prefix}
\begin{quote}

デフォルト: \code{-{-}-prefix=/usr/local/}.
ライブラリ等のインストールを行うディレクトリツリーを指定する.
\end{quote}

\code{-{-}with-mpi}
\begin{quote}

デフォルト: \code{-{-}with-mpi=no} (MPIを用いない).
MPIを用いるか (\code{-{-}with-mpi=yes}), 否かを指定する.
\end{quote}

\code{-{-}with-openmp}
\begin{quote}

デフォルト: \code{-{-}with-openmp=yes} (OpenMPを用いる).
OpenMPを用いるか否か (\code{-{-}with-openmp=no}) を指定する.
\end{quote}

\code{-{-}enable-shared}
\begin{quote}

デフォルト: \code{-{-}enable-shared}.
共有ライブラリを作成するか否か
\end{quote}

\code{-{-}enable-static}
\begin{quote}

デフォルト: \code{-{-}enable-static}.
静的ライブラリを作成するか否か.
\end{quote}

\code{-{-}disable-zdot}
\begin{quote}

デフォルト: \code{-{-}enable-zdot}.
MacOSXの標準のBLAS等では, ZDOTCおよびZDOTU関数が正常に動作しないため,
このオプションでこれらの関数を使わないようにする.
\end{quote}

\code{-{-}enable-threadsafe}
\begin{quote}

デフォルト: \code{-{-}disable-threadsafe}.
もしもOpenMPのパラレルリージョンの内側で \(K\omega\) を呼び出したい
(それぞれのスレッドで異なる問題を解きたい)場合には,
このオプションを用いる (\textbf{試験的}).
\end{quote}

\code{FC}
\begin{quote}

デフォルト: システムにインストールされているfortranコンパイラをスキャンして,
自動的に設定する. \code{-{-}with-mpiP} を指定した時にはそれに応じたコマンド
(\code{mpif90} 等)を自動で探し出して設定する.
\code{configure} の最後に出力される \code{FC} が望んだものでは無かった場合には
\code{./configure FC=gfortran} のように手で指定する.
\end{quote}

\code{-{-}help}
\begin{quote}

このオプションを指定した時には, ビルドの環境設定は行われず,
上記を含めたすべてのオプションを表示する.
\end{quote}


\chapter{プログラム内でのライブラリの動作イメージ}
\label{komega_workflow_ja::doc}\label{komega_workflow_ja:id1}
以下では \(N_R\) のループは省略する(各右辺ベクトルごとに同じ事をすればいいので).
また \(G_{i j}(z_k)\) の代わりに \(N_z\) 個の \(N_L\) 次元の解ベクトル \({\bf x}_{k}\) を求める.

ライブラリの各ルーチンの名前は次の通りである.
\begin{itemize}
\item {} 
\code{komega\_bicg\_init}, \code{komega\_cocg\_init}, \code{komega\_cg\_c\_init},
\code{komega\_cg\_r\_init}

ライブラリ内部で使う(ユーザーの目に触れない)変数のAllocateや初期値設定を行う.

\item {} 
\code{komega\_bicg\_update}, \code{komega\_cocg\_update},
\code{komega\_cg\_c\_update}, \code{komega\_cg\_r\_update}

Iteration の中で呼び出される. 解ベクトル群の更新等を行う.

\item {} 
\code{komega\_bicg\_finalize}, \code{komega\_cocg\_finalize},
\code{komega\_cg\_c\_finalize}, \code{komega\_cg\_r\_finalize}

Allocateしたライブラリ内部ベクトルを開放する.

\item {} 
\code{komega\_bicg\_getcoef}, \code{komega\_cocg\_getcoef},
\code{komega\_cg\_c\_getcoef}, \code{komega\_cg\_r\_getcoef}

各iterationで保存しておいた \(\alpha\), \(\beta\),
\(z_{\rm seed}\), \({\bf r}^{\rm L}\) を取り出す.

\item {} 
\code{komega\_bicg\_getvec}, \code{komega\_cocg\_getvec},
\code{komega\_cg\_c\_getvec}, \code{komega\_cg\_r\_getvec}

\({\boldsymbol r}\), \({\boldsymbol r}^{\rm old}\),
\({\tilde {\boldsymbol r}}\),
\({\tilde {\boldsymbol r}}^{\rm old}\) を取り出す.

\item {} 
\code{komega\_bicg\_restart}, \code{komega\_cocg\_restart},
\code{komega\_cg\_c\_restart}, \code{komega\_cg\_r\_restart}

保存しておいた \(\alpha\) 等を用いて,
新規の \(z\) での計算を行う.
\({\boldsymbol r}\) 等も有る場合には \code{komega\_bicg\_init},
\code{komega\_cocg\_init}, \code{komega\_cg\_c\_init}, \code{komega\_cg\_r\_init}
の代わりに用いてリスタートすることもできる.

\end{itemize}

\begin{notice}{note}{ノート:}\begin{itemize}
\item {} 
\code{komega\_*\_init} を呼び出す前にサイズ \(N_H\) のベクトルを2本
(BiCGの時には4本)Allocateしておく.

\item {} 
ハミルトニアン-ベクトル積を行う部分はあらかじめ作成しておく.

\item {} 
解ベクトルをAllocateしておく. ただし,
解ベクトルの長さは必ずしも \(N_H\) である必要はない.
実際前節の場合は \(N_L\) である.
この時(双)共役勾配ベクトル \({\bf p}_k\) も
\(N_z\) 本の \(N_L\) 次元のベクトルである.
ユーザーは \(N_H\) 次元の残差ベクトルを \(N_L\) 次元へ変換する
ルーチン/関数をあらかじめ作っておかなければならない.
\begin{gather}
\begin{split}\begin{aligned}
{\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
{\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
\end{aligned}\end{split}\notag
\end{gather}
\item {} 
\code{komega\_*\_update} の出力 \code{status} の第一成分が負の値になった場合には,
解が収束した, もしくは破たんしたことを表す.
したがって \code{status(1) \textless{} 0} でループを抜けるようにしておく.

\item {} 
\code{komega\_*\_update} 内での収束判定には,
シード点での残差ベクトルの2-ノルムが使われる.
すなわち, すべてのシフト点での残差ベクトルの2-ノルムが
\code{threshold} を下回った時に収束したと見做される.

\item {} 
各反復での \(\alpha, \beta, {\bf r}^{\rm L}\) を保存しておき,
あとで再利用する場合には最大反復回数 \code{itermax} を \code{0} 以外の値に設定する.

\end{itemize}
\end{notice}


\section{Shifted BiCGライブラリの動作イメージ}
\label{komega_workflow_ja:shifted-bicg}
Allocate \({\boldsymbol v}_{1 2}\), \({\boldsymbol v}_{1 3}\),
\({\boldsymbol v}_2\), \({\boldsymbol v}_3\),
\(\{{\bf x}_k\}, {\bf r}^{\rm L}\)
\({\boldsymbol v}_2 = {\boldsymbol \varphi_j}\)

\code{komega\_bicg\_init(N\_H, N\_L, N\_z, x, z, itermax, threshold)} start
\begin{quote}

Allocate \({\boldsymbol v}_3\), \({\boldsymbol v}_5\),
\(\{\pi_k\}\), \(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)

Copy \(\{z_k\}\)

\code{itermax} \(\neq\) \code{0} ならば \(\alpha\),
\(\beta\), \({\bf r}^{\rm L}\) を保存する配列を確保する.

\({\boldsymbol v}_4 = {\boldsymbol v}_2^*\) (任意),
\({\boldsymbol v}_3 = {\boldsymbol v}_5 = {\bf 0}\),

\({\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

( \({\boldsymbol v}_2 \equiv {\boldsymbol r}\),
\({\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}\),
\({\boldsymbol v}_4 \equiv {\tilde {\boldsymbol r}}\),
\({\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}\). )
\end{quote}

\code{komega\_bicg\_init} finish

do iteration
\begin{quote}

\({\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2\)

\({\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2\),
\({\boldsymbol v}_{1 4} = {\hat H} {\boldsymbol v}_4\)
{[} \(({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4}) = {\hat H} ({\boldsymbol v}_2, {\boldsymbol v}_4)\) とも書ける{]}

\code{komega\_bicg\_update(v\_12, v\_2, v\_14, v\_4, x, r\_small, status)} start
\begin{quote}

\(\circ\) シード方程式

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_4^* \cdot {\boldsymbol v}_2\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}\),
\({\boldsymbol v}_{1 4} = z_{\rm seed}^* {\boldsymbol v}_4 - {\boldsymbol v}_{1 4}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }\)

\(\circ\) シフト方程式

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

\({\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}\)

\({\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(k\)

\({\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2 - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3\),
\({\boldsymbol v}_3 = {\boldsymbol v}_2,\; {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}\)

\({\boldsymbol v}_{1 4} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old}*}} \right) {\boldsymbol v}_4 - \alpha^* {\boldsymbol v}_{1 4} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5\),
\({\boldsymbol v}_5 = {\boldsymbol v}_4,\; {\boldsymbol v}_4 = {\boldsymbol v}_{1 4}\)

\(\circ\) Seed switch

\(|\pi_k|\) が最も小さい \(k\) を探す.
\(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}\),
\({\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}\),
\({\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{*}\),
\({\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\),
\(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)
\end{quote}

\code{komega\_bicg\_update} finish

if(status(1) \textless{} 0 (これは \(|{\boldsymbol v}_2| <\) Threshold となった事を意味する)) exit
\end{quote}

end do iteration

\code{komega\_bicg\_finalize} start
\begin{quote}

Deallocate \({\boldsymbol v}_4\), \({\boldsymbol v}_5\),
\(\{\pi_k\}\), \(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)
\end{quote}

\code{komega\_bicg\_finalize} finish


\section{Shifted COCGライブラリの動作イメージ}
\label{komega_workflow_ja:shifted-cocg}
Allocate \({\boldsymbol v}_1\), \({\boldsymbol v}_2\),
\(\{{\bf x}_k\}, {\bf r}^{\rm L}\)
\({\boldsymbol v}_2 = {\boldsymbol \varphi_j}\)

\code{komega\_cocg\_init(N\_H, N\_L, N\_z, x, z, itermax, threshold)} start
\begin{quote}

Allocate \({\boldsymbol v}_3\), \(\{\pi_k\}\),
\(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)

Copy \(\{z_k\}\)

\code{itermax} \(\neq\) \code{0} ならば \(\alpha\),
\(\beta\), \({\bf r}^{\rm L}\) を保存する配列を確保する.

\({\boldsymbol v}_3 = {\bf 0}\),

\({\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0\)

( \({\boldsymbol v}_2 \equiv {\boldsymbol r}\),
\({\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}\). )
\end{quote}

\code{komega\_cocg\_init} finish

do iteration
\begin{quote}

\({\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2\)

\({\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2\)

\code{komega\_cocg\_update(v\_1, v\_2, x, r\_small, status)} start
\begin{quote}

\(\circ\) シード方程式

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }\)

\(\circ\) シフト方程式

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

\({\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}\)

\({\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}\)

\(\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(k\)

\({\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2 - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3\)

\({\boldsymbol v}_3 = {\boldsymbol v}_2\),
\({\boldsymbol v}_2 = {\boldsymbol v}_1\)

\(\circ\) Seed switch

\(|\pi_k|\) が最も小さい \(k\) を探す.
\(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}\),
\({\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\),
\(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)
\end{quote}

\code{komega\_cocg\_update} finish

if(status(1) \textless{} 0 (これは \(|{\boldsymbol v}_2| <\) Threshold となった事を意味する)) exit
\end{quote}

end do iteration

\code{komega\_cocg\_finalize} start
\begin{quote}

Deallocate \({\boldsymbol v}_3\), \(\{\pi_k\}\),
\(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)
\end{quote}

\code{komega\_cocg\_finalize} finish


\section{Shifted CGライブラリの動作イメージ}
\label{komega_workflow_ja:shifted-cg}
COCGと同様.


\chapter{使用方法}
\label{komega_usage_ja::doc}\label{komega_usage_ja:id1}
各ライブラリともユーザーはライブラリ名および型を指定し,
\begin{itemize}
\item {} 
初期設定 ({\hyperref[komega_usage_ja:init]{\emph{*\_init}}})

\item {} 
アップデート ({\hyperref[komega_usage_ja:update]{\emph{*\_update}}})

\item {} 
(オプション) 再計算用の情報を取り出す. ({\hyperref[komega_usage_ja:getcoef]{\emph{*\_getcoef}}}, {\hyperref[komega_usage_ja:getvec]{\emph{*\_getvec}}})

\item {} 
終了関数 ({\hyperref[komega_usage_ja:finalize]{\emph{*\_finalize}}})

\end{itemize}

の手順で関数を使用することで, 計算が実施される. なお,
リスタートを行う場合には
\begin{itemize}
\item {} 
前回の計算で残した再計算用の情報を用いた初期設定({\hyperref[komega_usage_ja:restart]{\emph{*\_restart}}})

\item {} 
アップデート ({\hyperref[komega_usage_ja:update]{\emph{*\_update}}})

\item {} 
(オプション) 更なる再計算用の情報を取り出す. ({\hyperref[komega_usage_ja:getcoef]{\emph{*\_getcoef}}}, {\hyperref[komega_usage_ja:getvec]{\emph{*\_getvec}}})

\item {} 
終了関数 ({\hyperref[komega_usage_ja:finalize]{\emph{*\_finalize}}})

\end{itemize}

の手順で実行する.

\begin{notice}{warning}{警告:}
\(K\omega\) はスレッドセーフ \textbf{ではない} ので,
これらのルーチンは必ずOpenMPのパラレルリージョンの外から
呼ばなければならない.
もしもパラレルリージョンの内側で \(K\omega\) を呼び出したい
(それぞれのスレッドで異なる問題を解きたい)場合には,
\code{configure} のオプション \code{-{-}enable-threadsafe} を利用する
({\hyperref[komega_install_ja:configoption]{\emph{configureのオプション}}} 参照). ただしこのモードは試験的なものである.
\end{notice}

fortran から呼び出すときには

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r} \PYG{c}{! 実ベクトルに対する共役勾配法}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c} \PYG{c}{! 複素ベクトルに対する共役勾配法}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cocg} \PYG{c}{! 共線直交共役勾配法}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}bicg} \PYG{c}{! 双共役勾配法}
\end{Verbatim}

のようにモジュールを呼び出す(すべてのモジュールを呼び出す必要はなく,
行う計算の種類に対応するものだけでよい).

C/C++で書かれたプログラムから呼び出すときには、

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include komega.h}
\end{Verbatim}

のようにヘッダーファイルを読み込む。
また、スカラー引数はすべてポインタとして渡す。

またMPI/ハイブリッド並列のときにライブラリに渡すコミュニケーター変数を,
次のようにC/C++のものからfortranのものに変換する。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{comm\PYGZus{}f} \PYG{o}{=} \PYG{n}{MPI\PYGZus{}Comm\PYGZus{}c2f}\PYG{p}{(}\PYG{n}{comm\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\section{各ルーチンの説明}
\label{komega_usage_ja:id2}

\subsection{*\_init}
\label{komega_usage_ja:init}\label{komega_usage_ja:id3}
ライブラリ内部変数の割り付けおよび初期化を行う.
シフト線形方程式を解く前に, 一番初めに実行する.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

パラメーター
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{ndim}
\end{Verbatim}
\begin{quote}

線形方程式の次元.
以降のサブルーチンのパラメーターの次元で現れる \code{ndim} は
これと同じものになる.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nl}
\end{Verbatim}
\begin{quote}

射影された解ベクトルの次元.
以降のサブルーチンのパラメーターの次元で現れる \code{nl} は
これと同じものになる.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nz}
\end{Verbatim}
\begin{quote}

シフト点の数.
以降のサブルーチンのパラメーターの次元で現れる \code{nz} は
これと同じものになる.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}init\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}init\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

解ベクトル. \code{0} ベクトルが返される.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}init\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}init\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

シフト点.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{itermax}
\end{Verbatim}
\begin{quote}

リスタート用配列の割り付けのための最大反復回数.
これを \code{0} にした場合にはリスタート用配列を割りつけない
(したがって後述のリスタート用変数の出力を行えない)
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{threshold}
\end{Verbatim}
\begin{quote}

収束判定用しきい値.
シード方程式の残差ベクトルの2-ノルムがこの値を下回った時に収束したと判定する.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)}\PYG{p}{,}\PYG{k}{OPTIONAL} \PYG{k+kd}{::} \PYG{n+nv}{comm}
\end{Verbatim}
\begin{quote}

オプショナル引数.
MPIのコミニュケーター( \code{MPI\_COMM\_WORLD} など)を入れる.
\(K\omega\) を内部でMPI/Hybrid並列するときのみ入力する.
C言語では使用しないときには \code{NULL} を入れる.
\end{quote}
\end{quote}


\subsection{*\_restart}
\label{komega_usage_ja:id4}\label{komega_usage_ja:restart}
リスタートを行う場合に {\hyperref[komega_usage_ja:init]{\emph{*\_init}}} の代わりに用いる.
ライブラリ内部変数の割り付けおよび初期化を行う.
シフト線形方程式を解く前に, 一番初めに実行する.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

パラメーター
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{ndim}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nl}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nz}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (それ以外)}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{itermax}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{threshold}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)}\PYG{p}{,}\PYG{k}{OPTIONAL} \PYG{k+kd}{::} \PYG{n+nv}{comm}
\end{Verbatim}
\begin{quote}

{\hyperref[komega_usage_ja:init]{\emph{*\_init}}} と同様.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

エラーコードを返す.

第一成分( \code{status(1)})
\begin{quote}

解が収束した場合,
もしくは計算が破綻した場合には現在の総反復回数に
マイナスが付いた値が返される.
それ以外の場合には現在の総反復回数(マイナスが付かない)が返される.
\code{status(1)} が正の値の時のみ反復を続行できる.
それ以外の場合は反復を進めても有意な結果は得られない.
\end{quote}

第二成分( \code{status(2)})
\begin{quote}

\code{itermax} を有限にして, かつ \code{itermax} 回の反復で
収束に達しなかった場合には \code{1} が返される.
\(\alpha\) が発散した場合には \code{2} が返される.
\(\pi_{\rm seed}\) が0にになった場合には \code{3} が返される.
\code{COCG\_restart} もしくは \code{BiCG\_restart} で,
残差ベクトルと影の残差ベクトルが直交した場合には \code{4} が返される.
それ以外の場合には \code{0} が返される.
\end{quote}

第三成分( \code{status(3)})
\begin{quote}

シード点のindexが返される.
\end{quote}
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{iter\PYGZus{}old}
\end{Verbatim}
\begin{quote}

先行する計算での反復回数.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での最後の残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での最後から2番目の残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での各反復での(Bi)CG法のパラメーター \(\alpha\).
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での各反復での(Bi)CG法のパラメーター \(\beta\).
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算でのシードシフト.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での各反復での射影された残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

\code{BiCG\_restart} の場合のみ使用.
先行する計算での最後の影の残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

\code{BiCG\_restart} の場合のみ使用.
先行する計算での最後から2番目の影の残差ベクトル.
\end{quote}
\end{quote}


\subsection{*\_update}
\label{komega_usage_ja:id5}\label{komega_usage_ja:update}
ループ内で行列ベクトル積と交互に呼ばれて解を更新する.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

パラメーター

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

入力は残差ベクトル( \code{v2})と行列の積. 出力は,
更新された残差ベクトルの2-ノルムが,
先頭の要素に格納される(これは収束の具合を表示して調べる時などに用いる).
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

入力は残差ベクトル.
出力は更新された残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

影の残差ベクトル( \code{v4})と行列の積.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

入力は影の残差ベクトル.
出力は更新された影の残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

エラーコードを返す.

第一成分( \code{status(1)})
\begin{quote}

解が収束した場合,
もしくは計算が破綻した場合には現在の総反復回数に
マイナスが付いた値が返される.
それ以外の場合には現在の総反復回数(マイナスが付かない)が返される.
\code{status(1)} が正の値の時のみ反復を続行できる.
それ以外の場合は反復を進めても有意な結果は得られない.
\end{quote}

第二成分( \code{status(2)})
\begin{quote}

{\hyperref[komega_usage_ja:init]{\emph{*\_init}}} ルーチンで, \code{itermax} を有限にして,
かつ \code{itermax} 回の反復で
収束に達しなかった場合には \code{1} が返される.
\(\alpha\) が発散した場合には \code{2} が返される.
\(\pi_{\rm seed}\) が0にになった場合には \code{3} が返される.
\code{COCG\_update} もしくは \code{BiCG\_update} で,
残差ベクトルと影の残差ベクトルが直交した場合には \code{4} が返される.
それ以外の場合には \code{0} が返される.
\end{quote}

第三成分( \code{status(3)})
\begin{quote}

シード点のindexが返される.
\end{quote}
\end{quote}
\end{quote}


\subsection{*\_getcoef}
\label{komega_usage_ja:getcoef}\label{komega_usage_ja:id6}
後でリスタートをするときに必要な係数を取得する.
このルーチンを呼び出すためには,
{\hyperref[komega_usage_ja:init]{\emph{*\_init}}} ルーチンで \code{itermax} を \code{0} 以外の値にしておく必要がある.

また, このルーチンで使われる総反復回数 (\code{iter\_old}) は {\hyperref[komega_usage_ja:update]{\emph{*\_update}}} の出力 \code{status}
を用いて次のように計算される.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{iter\PYGZus{}old} \PYG{o}{=} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

パラメーター
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

各反復での(Bi)CG法のパラメーター \(\alpha\).
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

各反復での(Bi)CG法のパラメーター \(\beta\).
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}cg\PYGZus{}c\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

シードシフト.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

各反復での射影された残差ベクトル.
\end{quote}
\end{quote}


\subsection{*\_getvec}
\label{komega_usage_ja:id7}\label{komega_usage_ja:getvec}
後でリスタートをするときに必要な残差ベクトルを取得する.
このルーチンを呼び出すためには,
{\hyperref[komega_usage_ja:init]{\emph{*\_init}}} ルーチンで \code{itermax} を \code{0} 以外の値にしておく必要がある.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{,} \PYG{n}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

パラメーター
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}getvec\PYGZdq{} の場合)}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (それ以外)}
\end{Verbatim}
\begin{quote}

先行する計算での最後から2番目の残差ベクトル.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

\code{BiCG\_getvec} の場合のみ使用.
先行する計算での最後から2番目の影の残差ベクトル.
\end{quote}
\end{quote}


\subsection{*\_getresidual}
\label{komega_usage_ja:getresidual}
各シフト点での残差ベクトルの2-ノルムを取得する.
このルーチンは {\hyperref[komega_usage_ja:init]{\emph{*\_init}}} と {\hyperref[komega_usage_ja:finalize]{\emph{*\_finalize}}} の間の
任意の場所で呼び出すことが出来る. また,
いつ何回呼び出しても最終的な計算結果には影響を与えない.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

パラメーター
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{res}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

各シフト点での残差ベクトルの2-ノルム.
\end{quote}
\end{quote}


\subsection{*\_finalize}
\label{komega_usage_ja:id8}\label{komega_usage_ja:finalize}
ライブラリ内部で割りつけた配列のメモリを解放する.

構文
\begin{quote}

Fortran

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

C/C++

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}


\section{Shifted BiCGライブラリを使用したソースコードの例}
\label{komega_usage_ja:shifted-bicg}
以下, 代表的な例としてShifted BiCGライブラリの場合の使用方法を記載する.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{PROGRAM }\PYG{n+nv}{my\PYGZus{}prog}
  \PYG{c}{!}
  \PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}bicg}\PYG{p}{,} \PYG{n+nv}{ONLY} \PYG{p}{:} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                       \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                       \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}
  \PYG{k}{USE }\PYG{n+nv}{solve\PYGZus{}cc\PYGZus{}routines}\PYG{p}{,} \PYG{n+nv}{ONLY} \PYG{p}{:} \PYG{n+nv}{input\PYGZus{}size}\PYG{p}{,} \PYG{n+nv}{input\PYGZus{}restart}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{projection}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{,} \PYG{n+nv}{generate\PYGZus{}system}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{output\PYGZus{}restart}\PYG{p}{,} \PYG{n+nv}{output\PYGZus{}result}
  \PYG{c}{!}
  \PYG{k}{IMPLICIT }\PYG{k}{NONE}
  \PYG{c}{!}
  \PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{ndim}\PYG{p}{,}    \PYG{p}{\PYGZam{}} \PYG{c}{! Size of Hilvert space}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{nz}\PYG{p}{,}      \PYG{p}{\PYGZam{}} \PYG{c}{! Number of frequencies}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{nl}\PYG{p}{,}      \PYG{p}{\PYGZam{}} \PYG{c}{! Number of Left vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! Max. number of iteraction}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{iter\PYGZus{}old}   \PYG{c}{! Number of iteraction of previous run}
  \PYG{c}{!}
  \PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{threshold} \PYG{c}{! Convergence Threshold}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! Seed frequency}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{z}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}         \PYG{c}{! (nz): Frequency}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{ham}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (ndim): Working vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (ndim): Working vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (nl) : Projeccted residual vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{x}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (nl,nz) : Projected result}
  \PYG{c}{!}
  \PYG{c}{! Variables for Restart}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{alpha}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (iter\PYGZus{}old)}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (nl,iter\PYGZus{}old) Projected residual vectors}
  \PYG{c}{!}
  \PYG{c}{! Variables for Restart}
  \PYG{c}{!}
  \PYG{k+kt}{INTEGER} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{iter}\PYG{p}{,}    \PYG{p}{\PYGZam{}} \PYG{c}{! Counter for Iteration}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k+kt}{LOGICAL} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! If .TRUE., sestart from the previous result}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{restart\PYGZus{}out}   \PYG{c}{! If .TRUE., save datas for the next run}
  \PYG{c}{!}
  \PYG{c}{! Input Size of vectors, numerical conditions}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}size}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{nz}\PYG{p}{)}
  \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}condition}\PYG{p}{(}\PYG{n+nv}{itermax}\PYG{p}{,}\PYG{n+nv}{threshold}\PYG{p}{,}\PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{,}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{ALLOCATE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}        \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{nz}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{ham}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{generate\PYGZus{}system}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{ham}\PYG{p}{,} \PYG{n+nv}{rhs}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  CG Initialization  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{)} \PYG{k}{THEN}
    \PYG{c}{!}
    \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{zseed}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{c}{!}
    \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{       }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{status}\PYG{p}{,} \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{k}{ELSE}
\PYG{k}{       }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{status}\PYG{p}{,} \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{k}{END }\PYG{k}{IF}
    \PYG{c}{!}
    \PYG{c}{! These vectors were saved in BiCG routine}
    \PYG{c}{!}
    \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{c}{!}
    \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{GOTO }\PYG{l+m+mi}{10}
    \PYG{c}{!}
  \PYG{k}{ELSE}
     \PYG{c}{!}
     \PYG{c}{! Generate Right Hand Side Vector}
     \PYG{c}{!}
     \PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{o}{=} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)}
     \PYG{n+nv}{v4}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{CONJG}\PYG{p}{(}\PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!v4(1:ndim) = v2(1:ndim)}
     \PYG{c}{!}
     \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{        }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{termax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
     \PYG{k}{ELSE}
\PYG{k}{        }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
     \PYG{k}{END }\PYG{k}{IF}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
  \PYG{c}{! BiCG Loop}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  CG Iteration  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{DO }\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nv}{itermax}
     \PYG{c}{!}
     \PYG{c}{! Projection of Residual vector into the space}
     \PYG{c}{! spaned by left vectors}
     \PYG{c}{!}
     \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{nl}\PYG{p}{)} \PYG{o}{=} \PYG{n+nv}{projection}\PYG{p}{(}\PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{nl}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{c}{! Matrix\PYGZhy{}vector product}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{(}\PYG{n+nv}{Ham}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{)}
     \PYG{k}{CALL }\PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{(}\PYG{n+nv}{Ham}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{c}{! Update result x with BiCG}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}(a,i,a,3i,a,e15.5)\PYGZsq{}}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}lopp : \PYGZdq{}}\PYG{p}{,} \PYG{n+nv}{iter}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                             \PYG{l+s+s2}{\PYGZdq{}, status : \PYGZdq{}}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                             \PYG{l+s+s2}{\PYGZdq{}, Res. : \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{DBLE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
     \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{EXIT}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{DO}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Converged in iteration \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Not Converged in iteration \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Alpha becomes infinity\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Pi\PYGZus{}seed becomes zero\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{  }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Residual \PYGZam{} Shadow residual are orthogonal\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}          \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
  \PYG{c}{! Total number of iteration}
  \PYG{c}{!}
  \PYG{n+nv}{iter\PYGZus{}old} \PYG{o}{=} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{c}{! Get these vectors for restart in the Next run}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
     \PYG{c}{!}
     \PYG{k}{ALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,}\PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{output\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                   \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
\PYG{l+m+mi}{10} \PYG{k}{CONTINUE}
  \PYG{c}{!}
  \PYG{c}{! Deallocate all intrinsic vectors}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{c}{! Output to a file}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{output\PYGZus{}result}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  Done  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
\PYG{k}{END }\PYG{k}{PROGRAM }\PYG{n+nv}{my\PYGZus{}prog}
\end{Verbatim}


\chapter{プログラムの再配布}
\label{komega_copyright_ja::doc}\label{komega_copyright_ja:id1}

\section{自分のプログラムにKomegaを含める}
\label{komega_copyright_ja:komega}
\(K\omega\) ライブラリは下記の {\hyperref[komega_copyright_ja:lgplicense]{\emph{Lesser General Public License}}} (LGPL)に基づいて配布されている.
これはかいつまんで言うと次のようなことである.
\begin{itemize}
\item {} 
個人的なプログラムや, 研究室や共同研究者等のグループでソースコードをやりとりする時には,
自由にコピペしたり改変して良い.

\item {} 
公開したり売ったりするプログラムに関しては次のとおりである.
\begin{itemize}
\item {} 
配布するソースコードに \(K\omega\) をそのまま,
あるいは改変して含めるときには, そのプログラム本体をLGPL/GPLで配布する.

\item {} 
配布するソースコードに含めず呼び出すだけならばライセンスによらず自由に配布できる.

\item {} 
ただしバイナリファイルを配布する場合に, そのバイナリに \(K\omega\) が
静的リンクされている場合にはLGPL/GPLで配布する.
動的リンクされている(したがって \(K\omega\) そのものはバイナリに含まれていない)
場合にはライセンスによらず自由に配布できる.

\end{itemize}

\end{itemize}


\section{Autoconfを使わずにKomegaをビルドする}
\label{komega_copyright_ja:autoconfkomega}
このパッケージではAutotools (Autoconf, Aitomake, Libtool)を使って \(K\omega\) をビルドしている.
もし再配布するソースコードに \(K\omega\) を含めるときに,
Autoconfの使用に支障がある場合には, 以下の簡易版のMakefileを使うと良い (タブに注意).

\begin{Verbatim}[commandchars=\\\{\}]
F90 = gfortran
FFLAGS = \PYGZhy{}fopenmp \PYGZhy{}g \PYGZhy{}O2 \PYGZsh{}\PYGZhy{}D\PYGZus{}\PYGZus{}MPI \PYGZhy{}D\PYGZus{}\PYGZus{}NO\PYGZus{}ZDOT \PYGZhy{}D\PYGZus{}\PYGZus{}KOMEGA\PYGZus{}THREAD

.SUFFIXES :
.SUFFIXES : .o .F90

OBJS = \PYGZbs{}
komega\PYGZus{}cg\PYGZus{}c.o \PYGZbs{}
komega\PYGZus{}cg\PYGZus{}r.o \PYGZbs{}
komega\PYGZus{}cocg.o \PYGZbs{}
komega\PYGZus{}bicg.o \PYGZbs{}
komega\PYGZus{}math.o \PYGZbs{}
komega\PYGZus{}vals.o

all:libkomega.a

libkomega.a:\PYGZdl{}(OBJS)
     ar cr libkomega.a \PYGZdl{}(OBJS)

.F90.o:
     \PYGZdl{}(F90) \PYGZhy{}c \PYGZdl{}\PYGZlt{} \PYGZdl{}(FFLAGS)

clean:
     rm \PYGZhy{}f *.o *.a *.mod

komega\PYGZus{}cg\PYGZus{}c.o:komega\PYGZus{}math.o
komega\PYGZus{}cg\PYGZus{}c.o:komega\PYGZus{}vals.o
komega\PYGZus{}cg\PYGZus{}r.o:komega\PYGZus{}math.o
komega\PYGZus{}cg\PYGZus{}r.o:komega\PYGZus{}vals.o
komega\PYGZus{}cocg.o:komega\PYGZus{}math.o
komega\PYGZus{}cocg.o:komega\PYGZus{}vals.o
komega\PYGZus{}bicg.o:komega\PYGZus{}math.o
komega\PYGZus{}bicg.o:komega\PYGZus{}vals.o
komega\PYGZus{}math.o:komega\PYGZus{}vals.o
\end{Verbatim}

プリプロセッサマクロ \code{\_\_MPI}, \code{\_\_NO\_ZDOT}, \code{\_\_KOMEGA\_THREAD} はそれぞれ
\code{configure} のオプション \code{-{-}with-mpi=yes}, \code{-{-}disable-zdot}, \code{-{-}enable-thread}
に対応する.


\section{Lesser General Public License}
\label{komega_copyright_ja:lesser-general-public-license}\label{komega_copyright_ja:lgplicense}
\emph{© 2016- The University of Tokyo. All rights reserved.}

\begin{DUlineblock}{0em}
\item[] This software is developed under the support of
\item[] ``\emph{Project for advancement of software usability in materials science}'' by The
\item[] Institute for Solid State Physics, The University of Tokyo.
\item[] 
\item[] This library is free software; you can redistribute it and/or
\item[] modify it under the terms of the GNU Lesser General Public
\item[] License as published by the Free Software Foundation; either
\item[] version 2.1 of the License, or (at your option) any later version.
\item[] This library is distributed in the hope that it will be useful,
\item[] but WITHOUT ANY WARRANTY; without even the implied warranty of
\item[] MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
\item[] Lesser General Public License for more details.
\item[] 
\item[] You should have received a copy of the GNU Lesser General Public
\item[] License along with this library; if not, write to the Free Software
\item[] Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
\item[] 
\item[] For more details, See `COPYING.LESSER' in the root directory of this library.
\end{DUlineblock}


\chapter{Contact}
\label{komega_contact_ja:contact}\label{komega_contact_ja::doc}
このライブラリについてのご意見, ご質問,
バグ報告等ありましたら下記までお問い合わせください。

河村光晶

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mkawamura\PYGZus{}at\PYGZus{}issp}\PYG{o}{.}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{tokyo}\PYG{o}{.}\PYG{n}{ac}\PYG{o}{.}\PYG{n}{jp}
\end{Verbatim}

\code{\_at\_}を\code{@}に変えてください.


\chapter{参考文献}
\label{komega_ref_ja:ref}\label{komega_ref_ja::doc}\label{komega_ref_ja:id1}
{[}1{]} A. Frommer, Computing \textbf{70}, 87 (2003).

{[}2{]} S. Yamamoto, T. Sogabe, T. Hoshi, S.-L. Zhang, and T. Fujiwara, J. Phys. Soc. Jpn. \textbf{77}, 114713 (2008).



\renewcommand{\indexname}{索引}
\printindex
\end{document}
