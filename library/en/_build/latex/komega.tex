% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,dvipdfmx,openany]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{$K\omega$ Documentation}
\date{January 27, 2017}
\release{0.2}
\author{}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Overview}
\label{komega_overview_en:overview}\label{komega_overview_en::doc}\label{komega_overview_en:welcome-to-s-documentation}
This document is a manual for \(K(\omega)\) which is the library to
solve the shifted linear equation within the Krylov subspace.
This library provides routines to solve the following shifted linear equation
(with the projection),
\phantomsection\label{komega_overview_en:shiftedeq}\begin{gather}
\begin{split}\begin{align}
  G_{i j}(z) = \langle i | (z {\hat I} -{\hat H})^{-1}| j \rangle \equiv
  {\boldsymbol \varphi}_i^{*} \cdot (z{\hat I}-{\hat H})^{-1} {\boldsymbol \varphi}_j.
  \end{align}\end{split}\notag
\end{gather}
The source codes of \(K(\omega)\) is written in FORTRAN
and requires the BLAS Level 1 routines.


\chapter{License}
\label{komega_copyright_en::doc}\label{komega_copyright_en:license}
\emph{Â© 2016- The University of Tokyo. All rights reserved.}

\begin{DUlineblock}{0em}
\item[] This software is developed under the support of
\item[] ``\emph{Project for advancement of software usability in materials science}'' by The
\item[] Institute for Solid State Physics, The University of Tokyo.
\item[] 
\item[] This library is free software; you can redistribute it and/or
\item[] modify it under the terms of the GNU Lesser General Public
\item[] License as published by the Free Software Foundation; either
\item[] version 2.1 of the License, or (at your option) any later version.
\item[] This library is distributed in the hope that it will be useful,
\item[] but WITHOUT ANY WARRANTY; without even the implied warranty of
\item[] MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
\item[] Lesser General Public License for more details.
\item[] 
\item[] You should have received a copy of the GNU Lesser General Public
\item[] License along with this library; if not, write to the Free Software
\item[] Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
\item[] 
\item[] For more details, See `COPYING.LESSER' in the root directory of this library.
\end{DUlineblock}


\chapter{Algorithm}
\label{komega_algorithm_en::doc}\label{komega_algorithm_en:algorithm}
This library provides the four kinds of numerical solvers.
The kind of solvers is selected under the condition whether the Hamiltonian
\({\hat H}\) and/or the frequency \(z\) are complex or real number.
It is noted that \({\hat H}\) must be Hermitian (symmetric)
for complex (real) number.
\begin{itemize}
\item {} 
(\({\hat H}\), \(z\) ) = (complex, complex):
Shifted Bi-Conjugate Gradient(BiCG) method {\hyperref[komega_ref_en:ref]{\emph{{[}1{]}}}}

\item {} 
(\({\hat H}\), \(z\) ) = (real, complex):
Shifted Conjugate Orthogonal Conjugate Gradient(COCG) method {\hyperref[komega_ref_en:ref]{\emph{{[}2{]}}}}

\item {} 
(\({\hat H}\), \(z\) ) = (complex, real):
Shifted Conjugate Gradient(CG) method (using complex vector)

\item {} 
(\({\hat H}\), \(z\) ) = (real, real):
Shifted Conjugate Gradient(CG) method (using real vector)

\end{itemize}

For above methods, seed switching {\hyperref[komega_ref_en:ref]{\emph{{[}2{]}}}} is adopted.
Hereafter, the number of the left (right) side vector is
written as \(N_L\) (\(N_R\)).
The details of each algorithm are written as follows.


\section{Shifted BiCG method with seed switching technique}
\label{komega_algorithm_en:shifted-bicg-method-with-seed-switching-technique}
\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\),

\({\tilde {\boldsymbol r}} =\) an arbitrary vector,
\({\boldsymbol r}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) Seed equation

\(\rho^{\rm old} = \rho,\; \rho = {\tilde {\boldsymbol r}}^* \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\tilde {\boldsymbol r}}^*\cdot{\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) Shifted equation

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\({\boldsymbol q} = (z_{\rm seed}^* {\hat I} - {\hat H}) {\tilde {\boldsymbol r}},\; {\boldsymbol q} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old}*}} \right) {\tilde {\boldsymbol r}} - \alpha^* {\boldsymbol q} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\tilde {\boldsymbol r}}^{\rm old},\; {\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}},\; {\tilde {\boldsymbol r}} = {\boldsymbol q}\)

\(\circ\) Seed switch

Search \(k\) which gives the smallest \(|\pi_k|\) . \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old},\; {\tilde {\boldsymbol r}} = {\tilde {\boldsymbol r}} / \pi_{\rm seed}^*,\; {\tilde {\boldsymbol r}}^{\rm old} = {\tilde {\boldsymbol r}}^{\rm old} / \pi_{\rm seed}^{{\rm old}*}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\section{Shifted COCG method with seed switching technique}
\label{komega_algorithm_en:shifted-cocg-method-with-seed-switching-technique}
This method is obtained by
\({\tilde {\boldsymbol r}} = {\boldsymbol r}^*,\; {\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{{\rm old}*}\)
in the BiCG method.

\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\), \({\boldsymbol r}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) Seed equation

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r} \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol r}\cdot{\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) Shifted equation

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\(\circ\) Seed switch

Search \(k\) which gives the smallest \(|\pi_k|\) . \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\section{Shifted CG method with seed switching technique}
\label{komega_algorithm_en:shifted-cg-method-with-seed-switching-technique}
This method is obtained by
\({\tilde {\boldsymbol r}} = {\boldsymbol r},\; {\tilde {\boldsymbol r}}^{\rm old} = {\boldsymbol r}^{\rm old}\)
in the BiCG method.

\(G_{i j}(z_k) = 0 (i=1 \cdots N_L,\; j = 1 \cdots N_R,\; k=1 \cdots N_z)\)

do \(j = 1 \cdots N_R\)
\begin{quote}

\({\boldsymbol r} = {\boldsymbol \varphi_j}\), \({\boldsymbol r}^{\rm old} = {\bf 0}\)

\(p_{i k} = 0(i=1 \cdots N_L,\; k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

do iteration
\begin{quote}

\(\circ\) Seed equation

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol r}^* \cdot {\boldsymbol r}\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol q} = (z_{\rm seed} {\hat I} - {\hat H}){\boldsymbol r}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol r}^* \cdot {\boldsymbol q} - \beta \rho / \alpha }\)

\(\circ\) Shifted equation

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

do \(i = 1 \cdots N_L\)
\begin{quote}

\(p_{i k} = \frac{1}{\pi_k} {\boldsymbol \varphi}_i^* \cdot {\boldsymbol r} + \left(\frac{\pi^{\rm old}_k}{\pi_k } \right)^2 \beta p_{i k}\)

\(G_{i j}(z_k) = G_{i j}(z_k) + \frac{\pi_k}{\pi_k^{\rm new}} \alpha p_{i k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(i\)
\end{quote}

end do \(k\)

\({\boldsymbol q} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol r} - \alpha {\boldsymbol q} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol r}^{\rm old},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r},\; {\boldsymbol r} = {\boldsymbol q}\)

\(\circ\) Seed switch

Search \(k\) which gives the minimum value of \(|\pi_k|\) . \(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol r} = {\boldsymbol r} / \pi_{\rm seed},\; {\boldsymbol r}^{\rm old} = {\boldsymbol r}^{\rm old} / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\), \(\rho = \rho / {\pi_{\rm seed}^{\rm old}}^2\)

\(\{\pi_k = \pi_k/\pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old}/\pi_{\rm seed}^{\rm old}\}\)

if( \(|{\boldsymbol r}| <\) Threshold) exit
\end{quote}

end do iteration
\end{quote}

end do \(j\)


\chapter{Schematic workflow of this library}
\label{komega_workflow_en:schematic-workflow-of-this-library}\label{komega_workflow_en::doc}
In the following description, the loop for \(N_R\) is omitted for
simplicity and instead of \(G_{i j}(z_k)\),
the \(N_L\)-dimensional vector \({\bf x}_{k}\)
is obtained by using the library.

The names of the routines is defined as follows.
\begin{itemize}
\item {} 
\code{komega\_bicg\_init}, \code{komega\_cocg\_init},
\code{komega\_cg\_c\_init}, \code{komega\_cg\_r\_init}

Set the initial conditions such as the allocation of variables used
in the library.

\item {} 
\code{komega\_bicg\_update}, \code{komega\_cocg\_update},
\code{komega\_cg\_c\_update}, \code{komega\_cg\_r\_update}

These routines are called in the iteration to update the solution
vectors.

\item {} 
\code{komega\_bicg\_finalize}, \code{komega\_cocg\_finalize},
\code{komega\_cg\_c\_finalize}, \code{komega\_cg\_r\_finalize}

Release the allocated vectors in the library.

\item {} 
\code{komega\_bicg\_getcoef}, \code{komega\_cocg\_getcoef},
\code{komega\_cg\_c\_getcoef}, \code{komega\_cg\_r\_getcoef}

Get the \(\alpha\), \(\beta\), \(z_{\rm seed}\),
\({\bf r}^{\rm L}\) conserved at each iteration.

\item {} 
\code{komega\_bicg\_getvec}, \code{komega\_cocg\_getvec},
\code{komega\_cg\_c\_getvec}, \code{komega\_cg\_r\_getvec}

Get the vectors \({\boldsymbol r}\),
\({\boldsymbol r}^{\rm old}\), \({\tilde {\boldsymbol r}}\),
\({\tilde {\boldsymbol r}}^{\rm old}\).

\item {} 
\code{komega\_bicg\_restart}, \code{komega\_cocg\_restart},
\code{komega\_cg\_c\_restart}, \code{CG\_R\_restart}

\end{itemize}

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
Give the vector size \(N_H\) corresponding to the size of the
Hilbert space and the number of the frequency \(z\).

\item {} 
Allocate the two vectors (in the case of BiCG method, four vectors)
with the size of \(N_H\).

\item {} 
Give the function for the Hamiltonian-vector production.

\item {} 
Allocate the solution vectors. It is noted that the length of each
solution vector is not always equal to \(N_H\).
In fact, the its length in the previous section is \(N_L\).
In this case, the length of the (bi-)conjugate gradient vector
\({\bf p}_k (k=1,\cdots N_z)\) also
becomes \(N_L\).
We have to prepare a code for projecting
\(N_H\)-dimensional vector onto \(N_L\)dimensional space.
\begin{gather}
\begin{split}\begin{aligned}
{\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol r}, \qquad
{\hat P} \equiv ({\boldsymbol \varphi}_1, \cdots, {\boldsymbol \varphi}_{N_L})
\end{aligned}\end{split}\notag
\end{gather}
\item {} 
If the result converges (or a breakdown occurs),
\code{komega\_*\_update} return the first element of \code{status}
as a negative integer.
Therefore, please exit loop when \code{status(1) \textless{} 0} .

\item {} 
The 2-norm is used for the convergence check in the routine \code{komega\_*\_update}.
Therefore, if 2-norms of residual vectors at all shift points
becomes smaller than \code{threshold},
this routine assumes the result is converged.

\item {} 
We can obtain the history of \(\alpha, \beta, {\bf r}^{\rm L}\)
for restarting calculation.
In this case, \code{itermax} must not be \code{0}.

\end{itemize}
\end{notice}


\section{The schematic workflow of shifted BiCG library}
\label{komega_workflow_en:the-schematic-workflow-of-shifted-bicg-library}
Allocate \({\boldsymbol v}_{1 2}\), \({\boldsymbol v}_{1 3}\),
\({\boldsymbol v}_2\), \({\boldsymbol v}_3\),
\(\{{\bf x}_k\}, {\bf r}^{\rm L}\)
\({\boldsymbol v}_2 = {\boldsymbol \varphi_j}\)

\code{komega\_bicg\_init(N\_H, N\_L, N\_z, x, z, itermax, threshold)} start
\begin{quote}

Allocate \({\boldsymbol v}_3\), \({\boldsymbol v}_5\),
\(\{\pi_k\}\) , \(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)

Copy \(\{z_k\}\)

If \code{itermax} \(\neq\) \code{0} ,
allocate arrays to store \(\alpha\), \(\beta\),
and:math:\emph{\{bf r\}\textasciicircum{}\{rm L\}} at each iteration.

\({\boldsymbol v}_4 = {\boldsymbol v}_2^*\) (an arbitrary vector),
\({\boldsymbol v}_3 = {\boldsymbol v}_5 = {\bf 0}\),

\({\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; z_{\rm seed}=0\)

( \({\boldsymbol v}_2 \equiv {\boldsymbol r}\),
\({\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}\),
\({\boldsymbol v}_4 \equiv {\tilde {\boldsymbol r}}\),
\({\boldsymbol v}_5 \equiv {\tilde {\boldsymbol r}}^{\rm old}\). )
\end{quote}

\code{komega\_bicg\_init} finish

do iteration
\begin{quote}

\({\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2\)

\({\boldsymbol v}_{1 2} = {\hat H} {\boldsymbol v}_2\),
\({\boldsymbol v}_{1 4} = {\hat H} {\boldsymbol v}_4\)
{[}Or \(({\boldsymbol v}_{1 2}, {\boldsymbol v}_{1 4}) = {\hat H} ({\boldsymbol v}_2, {\boldsymbol v}_4)\) {]}

\code{komega\_bicg\_update(v\_12, v\_2, v\_14, v\_4, x, r\_small, status)} start
\begin{quote}

\(\circ\) Seed equation

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_4^* \cdot {\boldsymbol v}_2\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol v}_{1 2} = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_{1 2}\),
\({\boldsymbol v}_{1 4} = z_{\rm seed}^* {\boldsymbol v}_4 - {\boldsymbol v}_{1 4}\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol v}_3^* \cdot {\boldsymbol v}_{1 2} - \beta \rho / \alpha }\)

\(\circ\) Shifted equation

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

\({\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}\)

\({\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}\)

\(\pi_k^{\rm old} = \pi_k\), \(\pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(k\)

\({\boldsymbol v}_{1 2} = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2 - \alpha {\boldsymbol v}_{1 2} - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3\),
\({\boldsymbol v}_3 = {\boldsymbol v}_2,\; {\boldsymbol v}_2 = {\boldsymbol v}_{1 2}\)

\({\boldsymbol v}_{1 4} = \left( 1 + \frac{\alpha^* \beta^*}{\alpha^{{\rm old}*}} \right) {\boldsymbol v}_4 - \alpha^* {\boldsymbol v}_{1 4} - \frac{\alpha^* \beta^*}{\alpha^{{\rm old} *}} {\boldsymbol v}_5\),
\({\boldsymbol v}_5 = {\boldsymbol v}_4,\; {\boldsymbol v}_4 = {\boldsymbol v}_{1 4}\)

\(\circ\) Seed switch

Search \(k\) which gives the smallest \(|\pi_k|\) .
\(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}\),
\({\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}\),
\({\boldsymbol v}_4 = {\boldsymbol v}_4 / \pi_{\rm seed}^{*}\),
\({\boldsymbol v}_5 = {\boldsymbol v}_5 / \pi_{\rm seed}^{\rm old *}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\),
\(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)
\end{quote}

\code{komega\_bicg\_update} finish

if(status(1) \textless{} 0 (This indicates \(|{\boldsymbol v}_2| <\) Threshold)) exit
\end{quote}

end do iteration

\code{komega\_bicg\_finalize} start
\begin{quote}

Deallocate \({\boldsymbol v}_4\), \({\boldsymbol v}_5\),
\(\{\pi_k\}\), \(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)
\end{quote}

\code{komega\_bicg\_finalize} finish


\section{The schematic workflow of shifted COCG library}
\label{komega_workflow_en:the-schematic-workflow-of-shifted-cocg-library}
Allocate \({\boldsymbol v}_1\), \({\boldsymbol v}_2\),
\(\{{\bf x}_k\}, {\bf r}^{\rm L}\)
\({\boldsymbol v}_2 = {\boldsymbol \varphi_j}\)

\code{komega\_cocg\_init(N\_H, N\_L, N\_z, x, z, itermax, threshold)} start
\begin{quote}

Allocate \({\boldsymbol v}_3\), \(\{\pi_k\}\),
\(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)

Copy \(\{z_k\}\)

If \code{itermax} \(\neq\) \code{0} , allocate arrays
to store \(\alpha\), \(\beta\), and \({\bf r}^{\rm L}\) .

\({\boldsymbol v}_3 = {\bf 0}\),

\({\bf p}_{k} = {\bf x}_k = {\bf 0}(k=1 \cdots N_z),\; \pi_k=\pi_k^{\rm old} = 1(k=1 \cdots N_z)\)

\(\rho = \infty,\; \alpha = 1,\; \beta=0,\; z_{\rm seed}=0\)

( \({\boldsymbol v}_2 \equiv {\boldsymbol r}\),
\({\boldsymbol v}_3 \equiv {\boldsymbol r}^{\rm old}\). )
\end{quote}

\code{komega\_cocg\_init} finish

do iteration
\begin{quote}

\({\bf r}^{\rm L} = {\hat P}^\dagger {\boldsymbol v}_2\)

\({\boldsymbol v}_1 = {\hat H} {\boldsymbol v}_2\)

\code{komega\_cocg\_update(v\_1, v\_2, x, r\_small, status)} start
\begin{quote}

\(\circ\) Seed equationw

\(\rho^{\rm old} = \rho,\; \rho = {\boldsymbol v}_2 \cdot {\boldsymbol v}_2\)

\(\beta = \rho / \rho^{\rm old}\)

\({\boldsymbol v}_1 = z_{\rm seed} {\boldsymbol v}_2 - {\boldsymbol v}_1\)

\(\alpha^{\rm old} = \alpha,\; \alpha = \frac{\rho}{{\boldsymbol v}_2 \cdot {\boldsymbol v}_1 - \beta \rho / \alpha }\)

\(\circ\) Shifted equations

do \(k = 1 \cdots N_z\)
\begin{quote}

\(\pi_k^{\rm new} = [1+\alpha(z_k-z_{\rm seed})]\pi_k - \frac{\alpha \beta}{\alpha^{\rm old}}(\pi_k^{\rm old} - \pi_k)\)

\({\bf p}_{k} = \frac{1}{\pi_k} {\bf r}^{\rm L} + \frac{\pi^{\rm old}_k \pi^{\rm old}_k}{\pi_k \pi_k} \beta {\bf p}_{k}\)

\({\bf x}_{k} = {\bf x}_{k} + \frac{\pi_k}{\pi_k^{\rm new}} \alpha {\bf p}_{k}\)

\(\pi_k^{\rm old} = \pi_k,\; \pi_k = \pi_k^{\rm new}\)
\end{quote}

end do \(k\)

\({\boldsymbol v}_1 = \left( 1 + \frac{\alpha \beta}{\alpha^{\rm old}} \right) {\boldsymbol v}_2 - \alpha {\boldsymbol v}_1 - \frac{\alpha \beta}{\alpha^{\rm old}} {\boldsymbol v}_3\)

\({\boldsymbol v}_3 = {\boldsymbol v}_2\),
\({\boldsymbol v}_2 = {\boldsymbol v}_1\)

\(\circ\) Seed switch

Search \(k\) which gives the smallest \emph{\textbar{}pi\_k\textbar{}} .
\(\rightarrow z_{\rm seed},\; \pi_{\rm seed},\; \pi_{\rm seed}^{\rm old}\)

\({\boldsymbol v}_2 = {\boldsymbol v}_2 / \pi_{\rm seed}\),
\({\boldsymbol v}_3 = {\boldsymbol v}_3 / \pi_{\rm seed}^{\rm old}\)

\(\alpha = (\pi_{\rm seed}^{\rm old} / \pi_{\rm seed}) \alpha\),
\(\rho = \rho / (\pi_{\rm seed}^{\rm old} \pi_{\rm seed}^{\rm old})\)

\(\{\pi_k = \pi_k / \pi_{\rm seed},\; \pi_k^{\rm old} = \pi_k^{\rm old} / \pi_{\rm seed}^{\rm old}\}\)
\end{quote}

\code{komega\_cocg\_update} finish

if(status(1) \textless{} 0 (This indicates \(|{\boldsymbol v}_2| <\) Threshold.)) exit
\end{quote}

end do iteration

\code{komega\_cocg\_finalize} start
\begin{quote}

Deallocate \({\boldsymbol v}_3\), \(\{\pi_k\}\),
\(\{\pi_k^{\rm old}\}\), \(\{{\bf p}_k\}\)
\end{quote}

\code{komega\_cocg\_finalize} finish


\section{The schematic workflow of shifted CG library}
\label{komega_workflow_en:the-schematic-workflow-of-shifted-cg-library}
The workflow is the same as that of the shifted COCG library.


\chapter{Usage}
\label{komega_usage_en:usage}\label{komega_usage_en::doc}
The calculation is done to utilize functions by the following
procedures.
\begin{itemize}
\item {} 
Initialization ({\hyperref[komega_usage_en:init]{\emph{*\_init}}})

\item {} 
Update results iteratively ({\hyperref[komega_usage_en:update]{\emph{*\_update}}})

\item {} 
(Optional) Take the information for the restart ({\hyperref[komega_usage_en:getcoef]{\emph{*\_getcoef}}}, {\hyperref[komega_usage_en:getvec]{\emph{*\_getvec}}})

\item {} 
Finalization ({\hyperref[komega_usage_en:finalize]{\emph{*\_finalize}}})

\end{itemize}

The restart calculation can be done by the following procedures.
\begin{itemize}
\item {} 
Initialization with the information of the previous calculation ({\hyperref[komega_usage_en:restart]{\emph{*\_restart}}})

\item {} 
Update results iteratively ({\hyperref[komega_usage_en:update]{\emph{*\_update}}})

\item {} 
(Optional) Take the information for the further restart ({\hyperref[komega_usage_en:getcoef]{\emph{*\_getcoef}}}, {\hyperref[komega_usage_en:getvec]{\emph{*\_getvec}}})

\item {} 
Finalization ({\hyperref[komega_usage_en:finalize]{\emph{*\_finalize}}})

\end{itemize}

\begin{notice}{warning}{Warning:}
Since \(K\omega\) is \textbf{not} thread safe,
these routine must be called from the outside of the OpenMP-parallel region.
\end{notice}

For FORTRAN, the modules can be called by

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r} \PYG{c}{! Conjugate\PYGZhy{}gradient method for real vectors}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c} \PYG{c}{! Conjugate\PYGZhy{}gradient method for complex vectors}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}cocg} \PYG{c}{! Conjugate\PYGZhy{}orthogonal conjugate\PYGZhy{}gradient mehod}
\PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}bicg} \PYG{c}{! Biconjugate\PYGZhy{}gradient method}
\end{Verbatim}

To utilize routines of
MPI / Hybrid parallelization version, the modules can be called as folows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{USE }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r}
\PYG{k}{USE }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c}
\PYG{k}{USE }\PYG{n+nv}{pkomega\PYGZus{}cocg}
\PYG{k}{USE }\PYG{n+nv}{pkomega\PYGZus{}bicg}
\end{Verbatim}

When we call \(K\omega\) from C/C++ codes,
we should include the header file as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include komega\PYGZus{}cg\PYGZus{}r.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include komega\PYGZus{}cg\PYGZus{}c.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include komega\PYGZus{}cocg.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include komega\PYGZus{}bicg.h}
\end{Verbatim}

Scaler arguments should be passed as pointers.
For MPI/Hybrid parallelized routine,
the above line becomes

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include pkomega\PYGZus{}cg\PYGZus{}r.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include pkomega\PYGZus{}cg\PYGZus{}c.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include pkomega\PYGZus{}cocg.h}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include pkomega\PYGZus{}bicg.h}
\end{Verbatim}

Also the communicator argument for the routine should be
transformed from the C/C++'s one to the fortran's one as follows.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{comm\PYGZus{}f} \PYG{o}{=} \PYG{n}{MPI\PYGZus{}Comm\PYGZus{}c2f}\PYG{p}{(}\PYG{n}{comm\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\section{Details of each routines}
\label{komega_usage_en:details-of-each-routines}

\subsection{*\_init}
\label{komega_usage_en:init}\label{komega_usage_en:id1}
Set and initialize internal variables in libraries. These routines
should be called first before solving the shifted equation.

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/Hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{)}
\end{Verbatim}

C/C++ Serial/OpenMP

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ MPI/Hybrid parallel

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{ndim}
\end{Verbatim}
\begin{quote}

The dimension of solution vectors for the linearized equation.
\code{ndim} for the dimension of variables in other routine is
equal to this.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nl}
\end{Verbatim}
\begin{quote}

The dimension of projected solution vectors.
\code{nl} for the dimension of variables in other routine is
equal to this.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nz}
\end{Verbatim}
\begin{quote}

The number of shifted points.
\code{nz} for the dimension of variables in other routine is
equal to this.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}init\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}init\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (for other cases)}
\end{Verbatim}
\begin{quote}

The solution vector. In this procedure, \code{0} vector is returned.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}init\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}init\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (for other cases)}
\end{Verbatim}
\begin{quote}

Shifted points.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{itermax}
\end{Verbatim}
\begin{quote}

The maximum iteration number for allocating arrays for the restart calculation.
When \code{itermax=0} , these arrays are not allocated,
and the restart calculation described later becomes unavailable.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{threshold}
\end{Verbatim}
\begin{quote}

The threshold value for the convergence determination.
When the 2-norm of the residual vector for the seed equation
becomes smaller than this value, the calculation is finished.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{comm}
\end{Verbatim}
\begin{quote}

Only for MPI / Hybrid parallelization
version. Communicators for MPI such as \code{MPI\_COMM\_WORLD}.
\end{quote}
\end{quote}


\subsection{*\_restart}
\label{komega_usage_en:id2}\label{komega_usage_en:restart}
For the restart calculation, these routines are used instead of {\hyperref[komega_usage_en:init]{\emph{*\_init}}}.
Set and initialize internal variables in libraries.
These routines should be called first before solving the shifted equation.

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{n+nv}{comm}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{p}{\PYGZam{}}
\PYG{p}{\PYGZam{}}                 \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ndim}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nl}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{nz}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{itermax}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{threshold}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{status}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v12}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}
\PYG{o}{\PYGZam{}}                 \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{ndim}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nl}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{nz}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{o}{*}\PYG{n+nv}{nz}\PYG{p}{)}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)} \PYG{c}{! (Other)}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{itermax}
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{threshold}
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{comm}
\end{Verbatim}
\begin{quote}

The definition is same as {\hyperref[komega_usage_en:init]{\emph{*\_init}}}. See the parameters in {\hyperref[komega_usage_en:init]{\emph{*\_init}}}.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

The error code is returned.

First component(\code{status(1)})
\begin{quote}

If the solution is converged or a breakdown occurs,
the current total number of iteration with the minus sign is returned.
In other cases, this routine returns the current total number of iteration.
The calculation is continuable only when \code{status(1)} is the positive value;
otherwise the result is meaningless even if the calculation is continued.
\end{quote}

Second component(\code{status(2)})
\begin{quote}

\code{1} is returned if \code{itermax} is set as a finite value and the
convergence condition is not satisfied at the \code{itermax}-th iteration.
\code{2} is returned if \(\alpha\) diverges.
\code{3} is returned if \(\pi_{\rm seed}\) becomes 0.
In the case of \code{COCG\_restart} or \code{BiCG\_restart},
\code{4} is returned if the residual vector and the shadow residual vector are orthogonal.
In other cases, \code{0} is returned.
\end{quote}

Third component(\code{status(3)})
\begin{quote}

The index of the seed point is returned.
\end{quote}
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{iter\PYGZus{}old}
\end{Verbatim}
\begin{quote}

The number of iteration for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The residual vector at the last step for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The residual vector at the second from the last step for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The parameters \(\alpha\) obtained by the
previous calculation at each steps by (Bi)CG methods.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The parameters \(\beta\) obtained
by the previous calculation at each steps by (Bi)CG methods.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The value of the seed shift for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The projected residual vector at each iteration for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The shadow residual vector at the last step for the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The shadow residual vector at the second last step for the previous calculation.
\end{quote}
\end{quote}


\subsection{*\_update}
\label{komega_usage_en:update}\label{komega_usage_en:id3}
It is called alternately with the matrix-vector product
in the loop and updates the solution.

Syntax
\begin{quote}

Fortran (Serial/OpenMPI)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMPI)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n}{v12}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v14}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{r\PYGZus{}l}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The product of the residual vector (\code{v2}) and the matrix.
This routine returns the 2-norm of the updated residual vector
as a first element of this array.
This returned value is used, for examples, for printing the convergence profile.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The residual vector is input and the updated residual vector is output.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The product of the shadow residual vector (\code{v4}) and the matrix is input.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}update\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{INOUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The shadow residual vector is input and the updated vector is output.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

The error code is returned.

First component (\code{status(1)})
\begin{quote}

If the solution is converged or a breakdown occurs,
the current total number of iteration with the minus sign is returned.
In other cases,
this routine returns the current total number of iteration.
The calculation is continuable only when \code{status(1)} is the positive value;
otherwise the result is meaningless even if the calculation is continued.
\end{quote}

Second component (\code{status(2)})
\begin{quote}

\code{1} is returned if \code{itermax} is set as a finite value in the
{\hyperref[komega_usage_en:init]{\emph{*\_init}}} routine and the convergence condition is not satisfied
at the \code{itermax}-th iteration.
\code{2} is returned if \(\alpha\) diverges.
\code{3} is returned if \(\pi_{\rm seed}\) becomes 0.
In the case of \code{COCG\_update} or \code{BiCG\_update},
\code{4} is returned if the residual vector and
the shadow residual vector are orthogonal.
In other cases, \code{0} is returned.
\end{quote}

Third component (\code{status(3)})
\begin{quote}

The index of the seed point is returned.
\end{quote}
\end{quote}
\end{quote}


\subsection{*\_getcoef}
\label{komega_usage_en:getcoef}\label{komega_usage_en:id4}
Get the coefficients used in the restart calculation.
To call these routines,
\code{itermax} in {\hyperref[komega_usage_en:init]{\emph{*\_init}}} routine must not be \code{0} .

The total number of iteration (\code{iter\_old}) used in this routine
is computed by using \code{status} which is an output of {\hyperref[komega_usage_en:update]{\emph{*\_update}}} as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{iter\PYGZus{}old} \PYG{o}{=} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n}{alpha\PYGZus{}save}\PYG{p}{,} \PYG{n}{beta\PYGZus{}save}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{alpha\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The parameters \(\alpha\) of the (Bi)CG method at each iteration.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{beta\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The parameters \(\beta\) of the (Bi)CG method at each iteration.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{}, \PYGZdq{}CG\PYGZus{}C\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

Seed shift.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (\PYGZdq{}CG\PYGZus{}R\PYGZus{}restart\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{IN}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The projected residual vectors at each iteration.
\end{quote}
\end{quote}


\subsection{*\_getvec}
\label{komega_usage_en:id5}\label{komega_usage_en:getvec}
Get the residual vectors to use the restart calculation.
To call these routines,
\code{itermax} in the {\hyperref[komega_usage_en:init]{\emph{*\_init}}} routine must not be \code{0}.

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{r\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{,} \PYG{n}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n}{r\PYGZus{}old}\PYG{p}{,} \PYG{n}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (for \PYGZdq{}CG\PYGZus{}R\PYGZus{}getvec\PYGZdq{})}
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{c}{! (Other)}
\end{Verbatim}
\begin{quote}

The residual vector at the second last step in the previous calculation.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{r\PYGZus{}tilde\PYGZus{}old}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

The shadow residual vector at the second last step in the previous calculation.
\end{quote}
\end{quote}


\subsection{*\_getresidual}
\label{komega_usage_en:getresidual}
Get the values of 2-norm of the residual vector at each shift points.
These routines can be called from anywhere between {\hyperref[komega_usage_en:init]{\emph{*\_init}}}
and {\hyperref[komega_usage_en:finalize]{\emph{*\_finalize}}} .
These routines do not affect the calculation results.

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n+nv}{res}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}getresidual}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

Parameters
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{INTENT}\PYG{p}{(}\PYG{n+nv}{OUT}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n+nv}{res}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)}
\end{Verbatim}
\begin{quote}

The values of 2-norm of the residual vector at each shift points are
returned.
\end{quote}
\end{quote}


\subsection{*\_finalize}
\label{komega_usage_en:id6}\label{komega_usage_en:finalize}
Release memories of the arrays stored in the library.

Syntax
\begin{quote}

Fortran (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Fortran (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{CALL }\PYG{n+nv}{pkomega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

C/C++ (Serial/OpenMP)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{komega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

C/C++ (MPI/hybrid parallel)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}r\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cg\PYGZus{}c\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}cocg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pkomega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}


\section{Sample codes for using shifted BiCG library}
\label{komega_usage_en:sample-codes-for-using-shifted-bicg-library}
As a typical example, the usage of shifted BiCG library is shown below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{PROGRAM }\PYG{n+nv}{my\PYGZus{}prog}
  \PYG{c}{!}
  \PYG{k}{USE }\PYG{n+nv}{komega\PYGZus{}bicg}\PYG{p}{,} \PYG{n+nv}{ONLY} \PYG{p}{:} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                       \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                       \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{,} \PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}
  \PYG{k}{USE }\PYG{n+nv}{solve\PYGZus{}cc\PYGZus{}routines}\PYG{p}{,} \PYG{n+nv}{ONLY} \PYG{p}{:} \PYG{n+nv}{input\PYGZus{}size}\PYG{p}{,} \PYG{n+nv}{input\PYGZus{}restart}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{projection}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{,} \PYG{n+nv}{generate\PYGZus{}system}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}                             \PYG{n+nv}{output\PYGZus{}restart}\PYG{p}{,} \PYG{n+nv}{output\PYGZus{}result}
  \PYG{c}{!}
  \PYG{k}{IMPLICIT }\PYG{k}{NONE}
  \PYG{c}{!}
  \PYG{k+kt}{INTEGER}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{ndim}\PYG{p}{,}    \PYG{p}{\PYGZam{}} \PYG{c}{! Size of Hilvert space}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{nz}\PYG{p}{,}      \PYG{p}{\PYGZam{}} \PYG{c}{! Number of frequencies}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{nl}\PYG{p}{,}      \PYG{p}{\PYGZam{}} \PYG{c}{! Number of Left vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! Max. number of iteraction}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{iter\PYGZus{}old}   \PYG{c}{! Number of iteraction of previous run}
  \PYG{c}{!}
  \PYG{k+kt}{REAL}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{threshold} \PYG{c}{! Convergence Threshold}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{z\PYGZus{}seed} \PYG{c}{! Seed frequency}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{z}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}         \PYG{c}{! (nz): Frequency}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{ham}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{v12}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (ndim): Working vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (ndim): Working vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! (nl) : Projeccted residual vector}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{x}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (nl,nz) : Projected result}
  \PYG{c}{!}
  \PYG{c}{! Variables for Restart}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{alpha}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (iter\PYGZus{}old)}
  \PYG{c}{!}
  \PYG{k+kt}{COMPLEX}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{k}{ALLOCATABLE}\PYG{p}{,}\PYG{k}{SAVE} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)} \PYG{c}{! (nl,iter\PYGZus{}old) Projected residual vectors}
  \PYG{c}{!}
  \PYG{c}{! Variables for Restart}
  \PYG{c}{!}
  \PYG{k+kt}{INTEGER} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{iter}\PYG{p}{,}    \PYG{p}{\PYGZam{}} \PYG{c}{! Counter for Iteration}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k+kt}{LOGICAL} \PYG{k+kd}{::} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{,} \PYG{p}{\PYGZam{}} \PYG{c}{! If .TRUE., sestart from the previous result}
  \PYG{p}{\PYGZam{}} \PYG{n+nv}{restart\PYGZus{}out}   \PYG{c}{! If .TRUE., save datas for the next run}
  \PYG{c}{!}
  \PYG{c}{! Input Size of vectors, numerical conditions}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}size}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{nz}\PYG{p}{)}
  \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}condition}\PYG{p}{(}\PYG{n+nv}{itermax}\PYG{p}{,}\PYG{n+nv}{threshold}\PYG{p}{,}\PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{,}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{ALLOCATE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}        \PYG{n+nv}{x}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{nz}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{(}\PYG{n+nv}{nz}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{ham}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{generate\PYGZus{}system}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{ham}\PYG{p}{,} \PYG{n+nv}{rhs}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  CG Initialization  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}in}\PYG{p}{)} \PYG{k}{THEN}
    \PYG{c}{!}
    \PYG{k}{CALL }\PYG{n+nv}{input\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{zseed}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{c}{!}
    \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{       }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{itermax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{status}\PYG{p}{,} \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{k}{ELSE}
\PYG{k}{       }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}restart}\PYG{p}{(} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{status}\PYG{p}{,} \PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{p}{\PYGZam{}}
       \PYG{p}{\PYGZam{}}    \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{k}{END }\PYG{k}{IF}
    \PYG{c}{!}
    \PYG{c}{! These vectors were saved in BiCG routine}
    \PYG{c}{!}
    \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
    \PYG{c}{!}
    \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{GOTO }\PYG{l+m+mi}{10}
    \PYG{c}{!}
  \PYG{k}{ELSE}
     \PYG{c}{!}
     \PYG{c}{! Generate Right Hand Side Vector}
     \PYG{c}{!}
     \PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{o}{=} \PYG{n+nv}{rhs}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)}
     \PYG{n+nv}{v4}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{CONJG}\PYG{p}{(}\PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{ndim}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!v4(1:ndim) = v2(1:ndim)}
     \PYG{c}{!}
     \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{        }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{termax}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
     \PYG{k}{ELSE}
\PYG{k}{        }\PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}init}\PYG{p}{(}\PYG{n+nv}{ndim}\PYG{p}{,} \PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{threshold}\PYG{p}{)}
     \PYG{k}{END }\PYG{k}{IF}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
  \PYG{c}{! BiCG Loop}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  CG Iteration  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{DO }\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nv}{itermax}
     \PYG{c}{!}
     \PYG{c}{! Projection of Residual vector into the space}
     \PYG{c}{! spaned by left vectors}
     \PYG{c}{!}
     \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{nl}\PYG{p}{)} \PYG{o}{=} \PYG{n+nv}{projection}\PYG{p}{(}\PYG{n+nv}{v2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nv}{nl}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{c}{! Matrix\PYGZhy{}vector product}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{(}\PYG{n+nv}{Ham}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{)}
     \PYG{k}{CALL }\PYG{n+nv}{hamiltonian\PYGZus{}prod}\PYG{p}{(}\PYG{n+nv}{Ham}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{c}{! Update result x with BiCG}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}update}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}(a,i,a,3i,a,e15.5)\PYGZsq{}}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}lopp : \PYGZdq{}}\PYG{p}{,} \PYG{n+nv}{iter}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                             \PYG{l+s+s2}{\PYGZdq{}, status : \PYGZdq{}}\PYG{p}{,} \PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                             \PYG{l+s+s2}{\PYGZdq{}, Res. : \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{DBLE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
     \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{EXIT}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{DO}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Converged in iteration \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Not Converged in iteration \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Alpha becomes infinity\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{     }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Pi\PYGZus{}seed becomes zero\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{ELSE }\PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{k}{THEN}
\PYG{k}{  }\PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}  Residual \PYGZam{} Shadow residual are orthogonal\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZam{}}
  \PYG{p}{\PYGZam{}}          \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
  \PYG{c}{! Total number of iteration}
  \PYG{c}{!}
  \PYG{n+nv}{iter\PYGZus{}old} \PYG{o}{=} \PYG{n+nb}{ABS}\PYG{p}{(}\PYG{n+nv}{status}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{c}{! Get these vectors for restart in the Next run}
  \PYG{c}{!}
  \PYG{k}{IF}\PYG{p}{(}\PYG{n+nv}{restart\PYGZus{}out}\PYG{p}{)} \PYG{k}{THEN}
     \PYG{c}{!}
     \PYG{k}{ALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{)}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getcoef}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
     \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}getvec}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,}\PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{CALL }\PYG{n+nv}{output\PYGZus{}restart}\PYG{p}{(}\PYG{n+nv}{iter\PYGZus{}old}\PYG{p}{,} \PYG{n+nv}{z\PYGZus{}seed}\PYG{p}{,} \PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{p}{\PYGZam{}}
     \PYG{p}{\PYGZam{}}                   \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{,} \PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{)}
     \PYG{c}{!}
     \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{alpha}\PYG{p}{,} \PYG{n+nv}{beta}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l\PYGZus{}save}\PYG{p}{)}
     \PYG{c}{!}
  \PYG{k}{END }\PYG{k}{IF}
  \PYG{c}{!}
\PYG{l+m+mi}{10} \PYG{k}{CONTINUE}
  \PYG{c}{!}
  \PYG{c}{! Deallocate all intrinsic vectors}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{komega\PYGZus{}bicg\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{c}{! Output to a file}
  \PYG{c}{!}
  \PYG{k}{CALL }\PYG{n+nv}{output\PYGZus{}result}\PYG{p}{(}\PYG{n+nv}{nl}\PYG{p}{,} \PYG{n+nv}{nz}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{DEALLOCATE}\PYG{p}{(}\PYG{n+nv}{v12}\PYG{p}{,} \PYG{n+nv}{v2}\PYG{p}{,} \PYG{n+nv}{v14}\PYG{p}{,} \PYG{n+nv}{v4}\PYG{p}{,} \PYG{n+nv}{r\PYGZus{}l}\PYG{p}{,} \PYG{n+nv}{x}\PYG{p}{,} \PYG{n+nv}{z}\PYG{p}{)}
  \PYG{c}{!}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  Done  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{}}
  \PYG{k}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)}
  \PYG{c}{!}
\PYG{k}{END }\PYG{k}{PROGRAM }\PYG{n+nv}{my\PYGZus{}prog}
\end{Verbatim}


\chapter{Contact}
\label{komega_contact_en:contact}\label{komega_contact_en::doc}
If you have any comments, questions, bug reports etc. about this library,
please contact to the main developer (Mitsuaki Kawamura) by
sending the e-mail (the address is shown below).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mkawamura\PYGZus{}at\PYGZus{}issp}\PYG{o}{.}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{tokyo}\PYG{o}{.}\PYG{n}{ac}\PYG{o}{.}\PYG{n}{jp}
\end{Verbatim}

Please change \code{\_at\_} into \code{@}, when you will send the e-mail.


\chapter{Reference}
\label{komega_ref_en:ref}\label{komega_ref_en::doc}\label{komega_ref_en:reference}
{[}1{]} A. Frommer, Computing \textbf{70}, 87 (2003).

{[}2{]} S. Yamamoto, T. Sogabe, T. Hoshi, S.-L. Zhang, and T. Fujiwara, J. Phys. Soc. Jpn. \textbf{77}, 114713 (2008).



\renewcommand{\indexname}{Index}
\printindex
\end{document}
